---
phase: 03-sse-weight-streaming
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/main.py
  - src/lib/scale-stream.ts
  - src/components/hplc/WeightInput.tsx
autonomous: true

must_haves:
  truths:
    - "When tech clicks 'Read Weight', a live-updating weight value appears immediately, streamed from the scale via SSE"
    - "When 5 consecutive readings are within 0.5 mg, a green stable indicator appears and 'Accept Weight' enables"
    - "When scale is offline or SCALE_HOST not configured, manual weight entry input appears instead of SSE controls"
    - "Tech can always manually enter a weight even when scale mode is active (escape hatch)"
  artifacts:
    - path: "backend/main.py"
      provides: "GET /scale/weight/stream SSE endpoint"
      contains: "stream_scale_weight"
    - path: "src/lib/scale-stream.ts"
      provides: "useScaleStream hook with stability detection"
      exports: ["useScaleStream", "ScaleReading", "ScaleStreamState"]
    - path: "src/components/hplc/WeightInput.tsx"
      provides: "Weight input component with SSE/manual dual mode"
      exports: ["WeightInput"]
  key_links:
    - from: "src/lib/scale-stream.ts"
      to: "GET /scale/weight/stream"
      via: "fetch with Bearer auth and AbortController"
      pattern: "fetch.*scale/weight/stream"
    - from: "src/components/hplc/WeightInput.tsx"
      to: "src/lib/scale-stream.ts"
      via: "useScaleStream hook"
      pattern: "useScaleStream"
    - from: "src/components/hplc/WeightInput.tsx"
      to: "GET /scale/status"
      via: "fetch on mount to determine scale vs manual mode"
      pattern: "fetch.*scale/status"
    - from: "backend/main.py (stream_scale_weight)"
      to: "backend/scale_bridge.py (ScaleBridge.read_weight)"
      via: "request.app.state.scale_bridge"
      pattern: "bridge\\.read_weight"
---

<objective>
Add the SSE weight streaming endpoint and frontend components that let a lab tech see live scale readings or enter weights manually.

Purpose: This is the bridge between Phase 2's ScaleBridge TCP client and Phase 4's wizard UI. It produces the reusable `WeightInput` component that Phase 4 drops into each wizard weighing step.

Output: One backend SSE endpoint, one frontend React hook, one weight input component with dual mode (live SSE / manual entry).
</objective>

<execution_context>
@C:\Users\forre\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\forre\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-scale-bridge/02-01-SUMMARY.md
@.planning/phases/03-sse-weight-streaming/03-RESEARCH.md

# Key source files to read before implementing
@backend/main.py
@backend/scale_bridge.py
@src/components/hplc/PeptideConfig.tsx
@src/lib/config.ts
@src/store/auth-store.ts
@src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GET /scale/weight/stream SSE endpoint</name>
  <files>backend/main.py</files>
  <action>
Add a `GET /scale/weight/stream` SSE endpoint to `backend/main.py` in the `# --- Scale endpoints` section, immediately after the existing `GET /scale/status` endpoint.

**Implementation (follow the exact existing SSE pattern from the 4 other SSE endpoints in main.py):**

1. Define the route:
   ```python
   @app.get("/scale/weight/stream")
   async def stream_scale_weight(
       request: Request,
       _current_user=Depends(get_current_user),
   ):
   ```

2. Get bridge from app state. If `None`, raise `HTTPException(status_code=503, detail="Scale not configured (SCALE_HOST not set)")`.

3. Define `async def event_generator()` with a `send_event(event_type: str, data: dict) -> str` helper that formats `f"event: {event_type}\ndata: {json.dumps(data)}\n\n"`.

4. In the generator loop:
   - Check `await request.is_disconnected()` at the top of each iteration — break if True
   - Call `await bridge.read_weight()` inside a try/except
   - On success: yield `send_event("weight", {"value": reading["value"], "unit": reading["unit"], "stable": reading["stable"]})`
   - On `ConnectionError` or `ValueError`: yield `send_event("error", {"message": str(e)})` — do NOT break, continue looping (bridge may reconnect)
   - `await asyncio.sleep(0.25)` at the end (4 Hz poll rate)
   - Wrap entire loop in `try/except asyncio.CancelledError: pass`

5. Import `StreamingResponse` from `starlette.responses` inside the function (per existing pattern — the codebase imports it per-endpoint, not globally). Import `asyncio` at the top of the function body.

6. Return `StreamingResponse(event_generator(), media_type="text/event-stream", headers={"Cache-Control": "no-cache", "Connection": "keep-alive", "X-Accel-Buffering": "no"})`.

**Critical details:**
- Do NOT open a new TCP connection — use the singleton `request.app.state.scale_bridge`
- Do NOT acquire any external lock — `bridge.read_weight()` internally manages its own `asyncio.Lock`
- The `send_event` helper is a nested function inside the generator (same as existing SSE endpoints)
- Use `json.dumps` for the data field (already imported at top of main.py)
  </action>
  <verify>
Start the backend and verify:
```bash
cd backend && .venv/Scripts/python.exe -c "
import ast, sys
with open('main.py') as f:
    tree = ast.parse(f.read())
routes = [
    node for node in ast.walk(tree)
    if isinstance(node, ast.FunctionDef) and node.name == 'stream_scale_weight'
]
assert len(routes) == 1, 'stream_scale_weight not found'
print('stream_scale_weight endpoint exists')
"
```

Also verify the endpoint responds 503 when SCALE_HOST is not set:
```bash
cd backend && .venv/Scripts/python.exe -c "
import requests
# Start server briefly or use existing running server
# Without SCALE_HOST, /scale/weight/stream should return 503
print('Endpoint structure verified via AST')
"
```

Run `npm run check:all` from the project root to ensure no regressions.
  </verify>
  <done>
`GET /scale/weight/stream` endpoint exists in `backend/main.py`. It returns 503 when scale is not configured. When scale is configured, it streams SSE events with `weight` and `error` event types at 4 Hz. Disconnect detection via `request.is_disconnected()` is present.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useScaleStream hook and WeightInput component</name>
  <files>src/lib/scale-stream.ts, src/components/hplc/WeightInput.tsx</files>
  <action>
**Part A: Create `src/lib/scale-stream.ts` — the `useScaleStream` custom hook**

Follow the existing SSE consumer pattern from `PeptideConfig.tsx` (fetch + ReadableStream + TextDecoder + AbortController).

1. Export interfaces:
   - `ScaleReading { value: number; unit: string; stable: boolean }`
   - `ScaleStreamState { reading: ScaleReading | null; error: string | null; streaming: boolean; stableCount: number; isStable: boolean }`

2. Export constants:
   - `STABILITY_THRESHOLD = 5`
   - `STABILITY_TOLERANCE_MG = 0.5`

3. Export `function useScaleStream(active: boolean)`:
   - State: `ScaleStreamState` via `useState` (initial: all null/false/0)
   - Refs: `abortRef` (AbortController | null), `windowRef` (number[] — rolling window for stability)
   - `stop` callback: abort controller, reset streaming to false
   - Main `useEffect` keyed on `[active, stop]`:
     - If `!active`: call `stop()`, return
     - Create `AbortController`, store in `abortRef`
     - Set `streaming: true, error: null`
     - `async function run()`:
       - `const token = getAuthToken()` from `@/store/auth-store`
       - `fetch(\`${getApiBaseUrl()}/scale/weight/stream\`, { headers: token ? { Authorization: \`Bearer ${token}\` } : {}, signal: controller.signal })`
       - Check `response.ok`, throw on error
       - Get reader from `response.body.getReader()`
       - `TextDecoder` + buffer-based SSE parsing (exact pattern from PeptideConfig.tsx):
         - Split buffer by `\n`, keep last incomplete chunk
         - Track `eventType` and `eventData` across lines
         - On blank line with eventType+eventData: parse JSON payload
       - **On `weight` event:**
         - Push `payload.value` to `windowRef.current`, keep last 5 values
         - Calculate stability: if window has 5 values AND `Math.max(...window) - Math.min(...window) <= 0.5` then `stableCount = 5` else `stableCount = 0`
         - `setState` with new reading, stableCount, isStable
       - **On `error` event:**
         - `setState` with `error: payload.message`
     - Catch: ignore `AbortError`, set error for anything else
     - Finally: set `streaming: false`
     - Call `run()` (fire and forget)
     - Return cleanup: `controller.abort()`
   - Return: `{ ...state, stop }`

**Important patterns to follow:**
- Use `getApiBaseUrl()` from `@/lib/config` (NOT hardcoded URL)
- Use `getAuthToken()` from `@/store/auth-store` (NOT useAuthStore hook — this runs in a callback)
- Do NOT use `EventSource` (cannot send auth headers)
- Do NOT put stability state in Zustand (transient, single-component state)
- React Compiler handles memoization — do NOT add manual `useMemo`/`useCallback` beyond the `stop` callback which genuinely needs stable identity

**Part B: Create `src/components/hplc/WeightInput.tsx` — dual-mode weight input**

1. Export interface `WeightInputProps`:
   - `stepKey: string` — measurement step key (e.g., "stock_vial_empty_mg")
   - `label: string` — human-readable label
   - `onAccept: (value: number, source: 'scale' | 'manual') => void`

2. Export `function WeightInput({ stepKey, label, onAccept }: WeightInputProps)`:
   - Local state: `scaleMode: 'loading' | 'scale' | 'manual'`, `streamActive: boolean`, `manualValue: string`
   - `useEffect` on mount: fetch `GET /scale/status` with auth headers. If `data.status === 'disabled'` → set `'manual'`, else set `'scale'`. On fetch error → set `'manual'`.
   - Call `useScaleStream(streamActive)` to get `{ reading, isStable, error, streaming, stop }`

3. Render three modes:
   - **`scaleMode === 'loading'`:** Render `<Skeleton className="h-24 w-full" />` (from shadcn)
   - **`scaleMode === 'manual'`:** Render a `Label` + `Input type="number" step="0.01"` + `Button("Accept")` that calls `onAccept(parseFloat(manualValue), 'manual')`. Button disabled when value empty or NaN.
   - **`scaleMode === 'scale'`:**
     - If not streaming: Show `<Button onClick={() => setStreamActive(true)}>Read Weight</Button>`
     - If streaming: Show live weight display in a `rounded-md border p-4 font-mono text-2xl` div. Green border+bg when `isStable`. Show `reading.value.toFixed(2) reading.unit` or dash when no reading.
     - Stability badge: When `isStable`, show `<Badge variant="outline" className="border-green-500 text-green-700">Stable</Badge>`
     - Error banner: When `error`, show `<Alert variant="destructive"><AlertDescription>{error} -- scale reconnecting...</AlertDescription></Alert>`
     - Buttons: "Accept Weight" (disabled until `isStable && reading`) calls `onAccept(reading.value, 'scale')` then `stop()` then `setStreamActive(false)`. "Cancel" calls `setStreamActive(false)`.
     - **Manual escape hatch:** A `<details>` element with `<summary>Enter manually instead</summary>` containing a number input and "Accept" button that calls `setStreamActive(false)` then `onAccept(parseFloat(manualValue), 'manual')`.

4. Import UI components from shadcn: `Button`, `Input`, `Label`, `Badge`, `Alert`, `AlertDescription`, `Skeleton`. Use existing import paths (check project for `@/components/ui/...` pattern).

**Zustand rule:** Do NOT import or use `useUIStore` for scale state. All state is local to this component and the hook. This is transient UI state that does not persist between sessions or share across components.
  </action>
  <verify>
Run TypeScript compilation and lint:
```bash
npm run check:all
```

Verify the hook and component files exist and export correctly:
```bash
npx tsc --noEmit
```

Verify no Zustand destructuring pattern violations (ast-grep check if available):
```bash
# Manual check: grep for destructuring patterns in new files
grep -n "useUIStore()" src/lib/scale-stream.ts src/components/hplc/WeightInput.tsx || echo "No Zustand destructuring violations"
```
  </verify>
  <done>
`src/lib/scale-stream.ts` exports `useScaleStream`, `ScaleReading`, `ScaleStreamState`, `STABILITY_THRESHOLD`, `STABILITY_TOLERANCE_MG`. The hook connects to `GET /scale/weight/stream` via fetch with JWT auth, parses SSE events, maintains a 5-reading rolling window for stability detection.

`src/components/hplc/WeightInput.tsx` exports `WeightInput` component. It checks `GET /scale/status` on mount to determine mode. In scale mode: shows "Read Weight" button, live weight display, stability indicator, "Accept Weight" button (enabled only when stable). In manual mode: shows number input with Accept button. Manual escape hatch is always available in scale mode via a collapsible details element.

`npm run check:all` passes with no errors.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Backend endpoint exists:** `GET /scale/weight/stream` returns 503 when SCALE_HOST is not set (correct behavior for manual-mode clients).

2. **Frontend compiles:** `npm run check:all` passes — no TypeScript errors, no lint violations, no ast-grep pattern failures.

3. **Hook structure:** `useScaleStream` exports the correct interface, uses `getApiBaseUrl()` and `getAuthToken()`, includes AbortController cleanup, and implements the rolling window stability detection algorithm.

4. **Component structure:** `WeightInput` fetches `/scale/status` on mount, renders manual input when `status === 'disabled'`, renders SSE UI otherwise, includes the `<details>` manual escape hatch in scale mode.

5. **No pattern violations:**
   - No `EventSource` usage (cannot send auth headers)
   - No Zustand destructuring
   - No manual `useMemo`/`useCallback` beyond what's needed for stable refs
   - Uses existing `getApiBaseUrl()` and `getAuthToken()` helpers
</verification>

<success_criteria>
- `GET /scale/weight/stream` endpoint in `backend/main.py` streams weight events at 4 Hz with disconnect detection
- `useScaleStream` hook in `src/lib/scale-stream.ts` consumes the SSE stream with stability detection (5 readings within 0.5 mg)
- `WeightInput` component in `src/components/hplc/WeightInput.tsx` renders live SSE mode or manual mode based on scale status
- `npm run check:all` passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-sse-weight-streaming/03-01-SUMMARY.md`
</output>
