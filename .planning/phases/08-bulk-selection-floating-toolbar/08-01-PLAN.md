---
phase: 08-bulk-selection-floating-toolbar
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/ui/checkbox.tsx
  - src/hooks/use-bulk-analysis-transition.ts
autonomous: true

must_haves:
  truths:
    - "Checkbox component renders a minus/dash icon when checked='indeterminate'"
    - "useBulkAnalysisTransition hook exposes selectedUids, toggleSelection, selectAll, clearSelection"
    - "useBulkAnalysisTransition hook exposes executeBulk that processes UIDs sequentially with progress tracking"
    - "executeBulk calls transitionAnalysis in a for...await loop (never Promise.all)"
    - "executeBulk calls onTransitionComplete once after loop completes, not per-item"
    - "executeBulk shows a single summary toast after all items processed"
  artifacts:
    - path: "src/components/ui/checkbox.tsx"
      provides: "Indeterminate visual (Minus icon) for checkbox"
      contains: "Minus"
    - path: "src/hooks/use-bulk-analysis-transition.ts"
      provides: "Bulk selection state + sequential bulk processing"
      exports: ["useBulkAnalysisTransition"]
  key_links:
    - from: "src/hooks/use-bulk-analysis-transition.ts"
      to: "src/lib/api.ts"
      via: "transitionAnalysis import"
      pattern: "import.*transitionAnalysis.*from.*api"
---

<objective>
Create the foundation pieces for bulk analysis operations: an indeterminate-aware Checkbox component and a complete `useBulkAnalysisTransition` hook that owns selection state and sequential bulk processing logic.

Purpose: These are self-contained building blocks that Plan 08-02 will wire into the AnalysisTable UI. Separating them allows focused implementation and easier verification.

Output: Updated `checkbox.tsx` with indeterminate visual, new `use-bulk-analysis-transition.ts` hook with full API.
</objective>

<execution_context>
@C:\Users\forre\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\forre\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-bulk-selection-floating-toolbar/08-RESEARCH.md
@src/hooks/use-analysis-transition.ts
@src/lib/api.ts
@src/components/ui/checkbox.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add indeterminate visual to Checkbox component</name>
  <files>src/components/ui/checkbox.tsx</files>
  <action>
Update the shared Checkbox component to show a Minus icon when in the indeterminate state.

1. Import `MinusIcon` from `lucide-react` (alongside existing `CheckIcon`)
2. Inside `CheckboxPrimitive.Indicator`, replace the single `CheckIcon` with two conditional icons:
   - `CheckIcon` with className `size-3.5` — visible only when `data-[state=checked]`, hidden when `data-[state=indeterminate]`
   - `MinusIcon` with className `size-3` — visible only when `data-[state=indeterminate]`, hidden when `data-[state=checked]`
3. Use Tailwind data attribute variants on each icon:
   - On CheckIcon: add `hidden` by default, show with parent's data-state. Since the Indicator itself only renders when checked OR indeterminate, the trick is: CheckIcon gets `data-[state=indeterminate]:hidden` (hide when indeterminate) — but the data-state is on the Indicator element itself.

Verified approach from research: The `CheckboxPrimitive.Indicator` element carries `data-state` attribute. Use this pattern inside the Indicator:

```tsx
<CheckboxPrimitive.Indicator
  data-slot="checkbox-indicator"
  className="flex items-center justify-center text-current transition-none"
>
  <CheckIcon className="size-3.5 group-data-[state=indeterminate]/checkbox-indicator:hidden" />
  <MinusIcon className="size-3 hidden group-data-[state=indeterminate]/checkbox-indicator:block" />
</CheckboxPrimitive.Indicator>
```

If the group-data approach does not work with Tailwind (the Indicator does not have a group name), use a simpler approach: wrap both icons and use CSS `[data-state=indeterminate] &` or just conditionally render based on the Indicator's data-state. The simplest reliable approach:

```tsx
<CheckboxPrimitive.Indicator
  data-slot="checkbox-indicator"
  className="flex items-center justify-center text-current transition-none"
>
  <CheckIcon className="size-3.5 data-[state=indeterminate]:hidden" />
  <MinusIcon className="size-3 hidden data-[state=indeterminate]:block" />
</CheckboxPrimitive.Indicator>
```

Note: `data-[state=indeterminate]` Tailwind variants on the icons reference the nearest ancestor with `data-state`, which is the Indicator itself. Test both icons render correctly: checked state shows checkmark, indeterminate state shows minus dash.

Also add `data-[state=indeterminate]:bg-primary data-[state=indeterminate]:text-primary-foreground data-[state=indeterminate]:border-primary` to the Root className so indeterminate state gets the same filled visual as checked state.
  </action>
  <verify>
Visually inspect the Checkbox by temporarily rendering three checkboxes in a test page:
- `<Checkbox checked={true} />` shows checkmark
- `<Checkbox checked="indeterminate" />` shows minus/dash icon with filled background
- `<Checkbox checked={false} />` shows empty box

Run `npm run check:all` to confirm no TypeScript or lint errors.
  </verify>
  <done>Checkbox component renders CheckIcon when checked=true, MinusIcon when checked="indeterminate", and empty when checked=false. All three states have correct visual styling.</done>
</task>

<task type="auto">
  <name>Task 2: Create useBulkAnalysisTransition hook</name>
  <files>src/hooks/use-bulk-analysis-transition.ts</files>
  <action>
Create a new hook that owns bulk selection state and sequential bulk processing. Follow the exact pattern from `use-analysis-transition.ts` for consistency.

**Exported types:**

```typescript
interface BulkProgress {
  current: number
  total: number
  transition: string  // e.g. 'submit' — needed by toolbar for progress text
}

interface UseBulkAnalysisTransitionOptions {
  onTransitionComplete?: () => void
}

interface UseBulkAnalysisTransitionReturn {
  selectedUids: Set<string>
  isBulkProcessing: boolean
  bulkProgress: BulkProgress | null
  toggleSelection: (uid: string) => void
  selectAll: (uids: string[]) => void
  clearSelection: () => void
  executeBulk: (uids: string[], transition: string) => Promise<void>
}
```

**Implementation details:**

1. `selectedUids` — `useState<Set<string>>(new Set())`
2. `toggleSelection(uid)` — add if not present, remove if present (new Set copy)
3. `selectAll(uids)` — replace selectedUids with new Set(uids)
4. `clearSelection()` — set to empty Set
5. `isBulkProcessing` — `useState<boolean>(false)`
6. `bulkProgress` — `useState<BulkProgress | null>(null)`
7. `executeBulk(uids, transition)` — the core function:
   - Set `isBulkProcessing = true`
   - Set `bulkProgress = { current: 0, total: uids.length, transition }`
   - Initialize `succeeded: string[]` and `failed: string[]`
   - `for` loop (NOT Promise.all) — per user decision in STATE.md:
     ```typescript
     for (let i = 0; i < uids.length; i++) {
       setBulkProgress({ current: i + 1, total: uids.length, transition })
       try {
         const response = await transitionAnalysis(
           uids[i]!,
           transition as 'submit' | 'verify' | 'retract' | 'reject'
         )
         if (response.success) succeeded.push(uids[i]!)
         else failed.push(uids[i]!)
       } catch {
         failed.push(uids[i]!)
       }
     }
     ```
   - After loop: call `onTransitionComplete?.()` ONCE (not per-item)
   - Call `clearSelection()` — clear all selections regardless of outcome (per research recommendation)
   - Set `isBulkProcessing = false`, `bulkProgress = null`
   - Summary toast:
     - All succeeded: `toast.success(\`${succeeded.length} analyses ${transitionLabel}ed\`)`
     - Some failed: `toast.warning(\`${succeeded.length} succeeded, ${failed.length} failed\`, { description: \`${failed.length} transition(s) could not be completed\` })`
     - Use a local TRANSITION_LABELS map (same as in use-analysis-transition.ts — hook must not import from component per STATE.md decision). Past-tense labels: submit->submitted, verify->verified, retract->retracted, reject->rejected.

8. Wrap `toggleSelection`, `selectAll`, `clearSelection`, `executeBulk` in `useCallback`.
9. Import `transitionAnalysis` from `@/lib/api` and `toast` from `sonner`.

**Anti-patterns to avoid:**
- Do NOT use `Promise.all` — locked decision
- Do NOT call `onTransitionComplete` per-item — single call after loop
- Do NOT import from AnalysisTable.tsx — hook is self-contained
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm the hook compiles with no type errors.
Run `npm run check:all` for full quality gate.
  </verify>
  <done>
`use-bulk-analysis-transition.ts` exports `useBulkAnalysisTransition` hook with: selectedUids (Set), toggleSelection, selectAll, clearSelection, isBulkProcessing, bulkProgress, executeBulk. The executeBulk function uses a for loop (sequential), calls onTransitionComplete once after completion, clears selection, and shows a summary toast.
  </done>
</task>

</tasks>

<verification>
- `npm run check:all` passes with no errors
- `checkbox.tsx` imports both CheckIcon and MinusIcon
- `use-bulk-analysis-transition.ts` imports `transitionAnalysis` from `@/lib/api`
- `use-bulk-analysis-transition.ts` contains `for` loop (not `Promise.all`)
- `use-bulk-analysis-transition.ts` calls `onTransitionComplete` exactly once (after loop, not inside loop)
</verification>

<success_criteria>
1. Checkbox component shows minus icon for indeterminate state with filled background styling
2. useBulkAnalysisTransition hook compiles and exports the complete API surface
3. Sequential processing pattern (for loop) is used, not Promise.all
4. Summary toast logic handles both all-success and partial-failure cases
5. No new dependencies added (all imports from existing packages)
</success_criteria>

<output>
After completion, create `.planning/phases/08-bulk-selection-floating-toolbar/08-01-SUMMARY.md`
</output>
