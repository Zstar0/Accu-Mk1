---
phase: 06-data-foundation-inline-editing
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - backend/main.py
autonomous: true

must_haves:
  truths:
    - "POST /wizard/senaite/analyses/{uid}/result sets the Result value on a SENAITE analysis and returns the new review_state"
    - "POST /wizard/senaite/analyses/{uid}/transition triggers a workflow transition and returns the new review_state"
    - "Backend verifies post-transition review_state matches expected state; returns error if SENAITE silently rejected the transition"
  artifacts:
    - path: "backend/main.py"
      provides: "Two new FastAPI endpoints for analysis result and transition"
      contains: "async def set_analysis_result"
    - path: "backend/main.py"
      provides: "Transition endpoint with state validation"
      contains: "async def transition_analysis"
  key_links:
    - from: "set_analysis_result endpoint"
      to: "SENAITE REST API /update/{uid}"
      via: "httpx POST with JSON body"
      pattern: "update.*uid.*Result"
    - from: "transition_analysis endpoint"
      to: "SENAITE REST API /update/{uid}"
      via: "httpx POST with transition JSON"
      pattern: "transition.*review_state"
---

<objective>
Create two backend FastAPI endpoints that proxy analysis result setting and workflow transitions to the SENAITE REST API, with post-transition state validation to catch silent rejections.

Purpose: These endpoints are the bridge between the frontend inline editing UI and SENAITE. The result endpoint sets a value; the transition endpoint triggers submit/verify/retract/reject. Both verify the actual post-operation state from SENAITE's response.
Output: Two working POST endpoints callable from Swagger UI against a live SENAITE instance.
</objective>

<execution_context>
@C:\Users\forre\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\forre\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key source patterns:
- backend/main.py ~line 5760: update_senaite_sample_fields — the existing proxy endpoint pattern to follow
- integration-service/app/adapters/senaite.py ~line 901: submit_analysis_result — the two-step SENAITE pattern (set Result then transition)
- SENAITE API: POST /senaite/@@API/senaite/v1/update/{uid} with JSON body
- SENAITE returns 200 OK for invalid transitions — must check review_state in response items[0]
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create analysis result endpoint</name>
  <files>backend/main.py</files>
  <action>
  Add a new endpoint AFTER the existing `update_senaite_sample_fields` endpoint (~line 5838).

  1. Create request/response Pydantic models:

  ```python
  class AnalysisResultRequest(BaseModel):
      result: str  # The result value to set

  class AnalysisResultResponse(BaseModel):
      success: bool
      message: str
      new_review_state: Optional[str] = None
      keyword: Optional[str] = None
  ```

  2. Create endpoint `POST /wizard/senaite/analyses/{uid}/result`:

  ```python
  @app.post(
      "/wizard/senaite/analyses/{uid}/result",
      response_model=AnalysisResultResponse,
  )
  async def set_analysis_result(
      uid: str,
      req: AnalysisResultRequest,
      _current_user=Depends(get_current_user),
  ):
  ```

  Implementation pattern (follow update_senaite_sample_fields):
  - Guard: if SENAITE_URL is None, return success=False, message="SENAITE not configured"
  - Create httpx.AsyncClient with timeout=30s, connect=5s, BasicAuth, follow_redirects=True
  - POST to `{SENAITE_URL}/senaite/@@API/senaite/v1/update/{uid}` with JSON body `{"Result": req.result}`
  - Check response: if `items` is empty or missing, return success=False with error message
  - Extract `keyword` from items[0].get("Keyword", "")
  - Extract `review_state` from items[0].get("review_state", "")
  - Return success=True with new_review_state and keyword

  Error handling (same pattern as update_senaite_sample_fields):
  - httpx.TimeoutException -> success=False, "SENAITE request timed out"
  - httpx.HTTPStatusError -> success=False, "SENAITE returned {status}: {detail}"
  - Exception -> success=False, "Update error: {e}"

  This endpoint ONLY sets the result value. It does NOT trigger a transition. The transition is a separate explicit action (Phase 07 will use it for submit-after-set).
  </action>
  <verify>
  1. Backend starts without errors: `cd backend && python -c "from main import app; print('OK')"`
  2. Check endpoint is registered: `cd backend && python -c "from main import app; routes = [r.path for r in app.routes]; assert '/wizard/senaite/analyses/{uid}/result' in routes; print('Endpoint registered')"`
  </verify>
  <done>POST /wizard/senaite/analyses/{uid}/result endpoint exists and follows the established proxy pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Create analysis transition endpoint with state validation</name>
  <files>backend/main.py</files>
  <action>
  Add a second endpoint immediately after the result endpoint.

  1. Create request model and expected-state mapping:

  ```python
  class AnalysisTransitionRequest(BaseModel):
      transition: str  # "submit", "verify", "retract", "reject"

  # After a successful transition, SENAITE should move to this review_state.
  # If the actual state differs, SENAITE silently rejected the transition.
  EXPECTED_POST_STATES: dict[str, str] = {
      "submit": "to_be_verified",
      "verify": "verified",
      "retract": "unassigned",  # retract from to_be_verified goes back to unassigned
      "reject": "rejected",
  }
  ```

  2. Create endpoint `POST /wizard/senaite/analyses/{uid}/transition`:

  ```python
  @app.post(
      "/wizard/senaite/analyses/{uid}/transition",
      response_model=AnalysisResultResponse,  # Reuse same response model
  )
  async def transition_analysis(
      uid: str,
      req: AnalysisTransitionRequest,
      _current_user=Depends(get_current_user),
  ):
  ```

  Implementation:
  - Guard: if SENAITE_URL is None, return success=False
  - Validate transition is in EXPECTED_POST_STATES keys; if not, return success=False, "Invalid transition: {req.transition}"
  - Create httpx.AsyncClient (same pattern)
  - POST to `{SENAITE_URL}/senaite/@@API/senaite/v1/update/{uid}` with JSON body `{"transition": req.transition}`
  - Check response: if `items` is empty or missing, return success=False
  - Extract actual_state from items[0].get("review_state", "")
  - Extract keyword from items[0].get("Keyword", "")
  - **DATA-04 critical check**: Compare actual_state to EXPECTED_POST_STATES[req.transition]. If they differ, return success=False with message: "Transition '{req.transition}' was silently rejected by SENAITE. Expected state '{expected}' but got '{actual_state}'."
  - If states match, return success=True with new_review_state=actual_state and keyword

  Same error handling pattern as Task 1.

  NOTE: For "retract" from "verified" state, SENAITE may transition to "retracted" (not "unassigned"). The EXPECTED_POST_STATES mapping handles the common case. Phase 07 will refine this if needed. For now, keep it simple — the state validation will correctly flag unexpected states.
  </action>
  <verify>
  1. Backend starts: `cd backend && python -c "from main import app; print('OK')"`
  2. Both endpoints registered: `cd backend && python -c "from main import app; routes = [r.path for r in app.routes]; assert '/wizard/senaite/analyses/{uid}/transition' in routes; print('Transition endpoint registered')"`
  3. EXPECTED_POST_STATES exists: `cd backend && python -c "from main import EXPECTED_POST_STATES; print(EXPECTED_POST_STATES)"`
  </verify>
  <done>POST /wizard/senaite/analyses/{uid}/transition endpoint exists with EXPECTED_POST_STATES validation (DATA-04). Both endpoints follow the established SENAITE proxy pattern.</done>
</task>

</tasks>

<verification>
1. Backend starts without import errors
2. Both new routes are registered in the FastAPI app
3. EXPECTED_POST_STATES constant exists and maps submit/verify/retract/reject
4. Both endpoints follow the same httpx/error-handling pattern as update_senaite_sample_fields
5. Transition endpoint includes post-state validation (DATA-04)
</verification>

<success_criteria>
- POST /wizard/senaite/analyses/{uid}/result endpoint is callable and proxies to SENAITE
- POST /wizard/senaite/analyses/{uid}/transition endpoint is callable and proxies to SENAITE
- Transition endpoint validates post-transition review_state against EXPECTED_POST_STATES
- Mismatched state returns success=False with descriptive error (DATA-04)
- Both endpoints require JWT authentication (Depends(get_current_user))
</success_criteria>

<output>
After completion, create `.planning/phases/06-data-foundation-inline-editing/06-02-SUMMARY.md`
</output>
