---
phase: 06-data-foundation-inline-editing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/main.py
  - src/lib/api.ts
autonomous: true

must_haves:
  truths:
    - "Each analysis object returned by the lookup endpoint includes a uid string"
    - "Each analysis object returned by the lookup endpoint includes a keyword string"
    - "Frontend SenaiteAnalysis interface includes uid and keyword fields"
  artifacts:
    - path: "backend/main.py"
      provides: "SenaiteAnalysis Pydantic model with uid and keyword fields"
      contains: "uid: Optional[str]"
    - path: "src/lib/api.ts"
      provides: "SenaiteAnalysis TypeScript interface with uid and keyword fields"
      contains: "uid: string | null"
  key_links:
    - from: "backend/main.py (analysis loop ~line 5304)"
      to: "SenaiteAnalysis constructor"
      via: "uid and keyword mapped from an_item"
      pattern: "uid=an_item\\.get"
---

<objective>
Add uid and keyword fields to the SenaiteAnalysis data model (backend Pydantic + frontend TypeScript) and map them from the SENAITE API response in the lookup endpoint.

Purpose: Every subsequent plan (backend endpoints, inline editing) needs the analysis UID to address individual analyses. The keyword is needed for logging and display context.
Output: Updated SenaiteAnalysis model in both backend and frontend with uid/keyword populated from SENAITE responses.
</objective>

<execution_context>
@C:\Users\forre\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\forre\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key source locations:
- backend/main.py ~line 5005: SenaiteAnalysis Pydantic model
- backend/main.py ~line 5304: SenaiteAnalysis constructor call in lookup endpoint
- src/lib/api.ts ~line 2016: SenaiteAnalysis TypeScript interface
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add uid and keyword to backend SenaiteAnalysis model and mapping</name>
  <files>backend/main.py</files>
  <action>
  1. Add two fields to the `SenaiteAnalysis` Pydantic model (~line 5005):
     - `uid: Optional[str] = None` — the SENAITE analysis object UID
     - `keyword: Optional[str] = None` — the SENAITE analysis service keyword (e.g. "Purity", "Quantity")
     Place them BEFORE the `title` field so uid/keyword are the first fields (they are identifiers).

  2. In the analysis mapping loop (~line 5304 where `senaite_analyses.append(SenaiteAnalysis(...))` is called), add two arguments to the constructor:
     - `uid=an_item.get("uid") or an_item.get("UID") or None`
     - `keyword=an_item.get("Keyword") or an_item.get("getKeyword") or None`

  The SENAITE API response items always include `uid` (lowercase) and `Keyword` fields when `complete=yes` is passed. The lookup endpoint already requests `complete=yes` (~line 5234).
  </action>
  <verify>
  Run: `cd backend && python -c "from main import SenaiteAnalysis; a = SenaiteAnalysis(title='Test', uid='abc123', keyword='Purity'); print(a.uid, a.keyword)"`
  Expected output: `abc123 Purity`
  </verify>
  <done>SenaiteAnalysis Pydantic model includes uid and keyword fields, and the lookup endpoint maps them from SENAITE API response data.</done>
</task>

<task type="auto">
  <name>Task 2: Add uid and keyword to frontend SenaiteAnalysis interface</name>
  <files>src/lib/api.ts</files>
  <action>
  1. Add two fields to the `SenaiteAnalysis` TypeScript interface (~line 2016):
     - `uid: string | null` — placed as the FIRST field in the interface (identifier)
     - `keyword: string | null` — placed as the SECOND field

  The interface must match the backend Pydantic model field names exactly. Both are nullable because older cached responses or edge cases might not have them.

  2. Run typecheck to confirm no TypeScript errors are introduced. The existing code only reads `title`, `result`, `unit`, `method`, `instrument`, `analyst`, `due_date`, `review_state`, `sort_key`, `captured`, `retested` — adding new optional fields is backward-compatible.
  </action>
  <verify>
  Run: `npm run typecheck` from the project root. Must pass with zero errors.
  Also verify the interface has uid and keyword by reading the file.
  </verify>
  <done>Frontend SenaiteAnalysis interface includes uid and keyword fields matching the backend model.</done>
</task>

</tasks>

<verification>
1. Backend model instantiation works with uid and keyword fields
2. `npm run typecheck` passes
3. Both backend and frontend models have matching field names and types
</verification>

<success_criteria>
- SenaiteAnalysis Pydantic model has uid (Optional[str]) and keyword (Optional[str]) fields
- Lookup endpoint maps uid and keyword from SENAITE response items
- SenaiteAnalysis TypeScript interface has uid (string | null) and keyword (string | null) fields
- TypeScript typecheck passes
</success_criteria>

<output>
After completion, create `.planning/phases/06-data-foundation-inline-editing/06-01-SUMMARY.md`
</output>
