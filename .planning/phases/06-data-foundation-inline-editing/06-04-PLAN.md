---
phase: 06-data-foundation-inline-editing
plan: 04
type: execute
wave: 3
depends_on: ["06-02", "06-03"]
files_modified:
  - src/lib/api.ts
  - src/hooks/use-analysis-editing.ts
  - src/components/senaite/AnalysisTable.tsx
autonomous: false

must_haves:
  truths:
    - "User can click a result cell on an unassigned analysis to enter/edit the value inline"
    - "Pressing Enter saves the value and the cell updates immediately with a success toast"
    - "Pressing Escape cancels the edit with no change persisted"
    - "A failed save rolls back the cell to its previous value with an error toast"
    - "Tab moves focus to the next editable result cell"
  artifacts:
    - path: "src/lib/api.ts"
      provides: "setAnalysisResult frontend API function"
      contains: "export async function setAnalysisResult"
    - path: "src/hooks/use-analysis-editing.ts"
      provides: "useAnalysisEditing hook managing edit state, save, cancel, Tab navigation"
      contains: "export function useAnalysisEditing"
    - path: "src/components/senaite/AnalysisTable.tsx"
      provides: "Click-to-edit result cells wired to useAnalysisEditing"
      contains: "useAnalysisEditing"
  key_links:
    - from: "src/components/senaite/AnalysisTable.tsx"
      to: "src/hooks/use-analysis-editing.ts"
      via: "hook call in AnalysisTable"
      pattern: "useAnalysisEditing"
    - from: "src/hooks/use-analysis-editing.ts"
      to: "src/lib/api.ts setAnalysisResult"
      via: "API call on save"
      pattern: "setAnalysisResult"
    - from: "src/lib/api.ts setAnalysisResult"
      to: "POST /wizard/senaite/analyses/{uid}/result"
      via: "fetch call"
      pattern: "analyses.*result"
---

<objective>
Wire inline result editing into the AnalysisTable — click a result cell to edit, Enter to save, Escape to cancel, Tab to move to next editable cell, with optimistic update and rollback on error.

Purpose: This is the core user-facing feature of Phase 06. Lab staff can enter analysis results directly from the Sample Details page without navigating to SENAITE.
Output: Working inline editing with toast feedback, connected to the backend result endpoint.
</objective>

<execution_context>
@C:\Users\forre\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\forre\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-data-foundation-inline-editing/06-01-SUMMARY.md
@.planning/phases/06-data-foundation-inline-editing/06-02-SUMMARY.md
@.planning/phases/06-data-foundation-inline-editing/06-03-SUMMARY.md

Key patterns:
- src/components/dashboard/EditableField.tsx — existing optimistic update pattern (save/rollback/toast). Reference for the UX flow but do NOT reuse this component directly. The analysis table needs cell-level editing (not DataRow layout).
- src/lib/api.ts — getBearerHeaders(), API_BASE_URL() pattern for new API functions
- src/hooks/ directory — all hooks live here, named use-*.ts
- CRITICAL: Use savePending ref guard to prevent double-save from onBlur + onKeyDown Enter firing simultaneously
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add frontend API function for setting analysis result</name>
  <files>src/lib/api.ts</files>
  <action>
  Add a new exported async function near the existing SENAITE functions (after `updateSenaiteSampleFields` ~line 2100):

  ```typescript
  export interface AnalysisResultResponse {
    success: boolean
    message: string
    new_review_state: string | null
    keyword: string | null
  }

  export async function setAnalysisResult(
    uid: string,
    result: string
  ): Promise<AnalysisResultResponse> {
    const response = await fetch(
      `${API_BASE_URL()}/wizard/senaite/analyses/${encodeURIComponent(uid)}/result`,
      {
        method: 'POST',
        headers: getBearerHeaders('application/json'),
        body: JSON.stringify({ result }),
      }
    )
    if (!response.ok) {
      const err = await response.json().catch(() => null)
      throw new Error(err?.detail || `Set result failed: ${response.status}`)
    }
    return response.json()
  }
  ```

  Follow the exact same pattern as `updateSenaiteSampleFields` for error handling.
  </action>
  <verify>
  `npm run typecheck` passes.
  </verify>
  <done>setAnalysisResult function exists in api.ts and matches the backend endpoint contract.</done>
</task>

<task type="auto">
  <name>Task 2: Create useAnalysisEditing hook and wire into AnalysisTable</name>
  <files>src/hooks/use-analysis-editing.ts, src/components/senaite/AnalysisTable.tsx</files>
  <action>
  **Part A: Create `src/hooks/use-analysis-editing.ts`**

  This hook manages which analysis cell is being edited, the draft value, save/cancel logic, and Tab navigation.

  ```typescript
  interface UseAnalysisEditingOptions {
    analyses: SenaiteAnalysis[]
    onResultSaved?: (uid: string, newResult: string, newReviewState: string | null) => void
  }

  interface UseAnalysisEditingReturn {
    editingUid: string | null
    draft: string
    isSaving: boolean
    startEditing: (uid: string, currentResult: string | null) => void
    cancelEditing: () => void
    setDraft: (value: string) => void
    handleKeyDown: (e: React.KeyboardEvent, uid: string) => void
    save: (uid: string) => Promise<void>
  }
  ```

  Implementation details:

  1. State: `editingUid` (string | null), `draft` (string), `isSaving` (boolean)
  2. `savePendingRef = useRef(false)` — guard against double-save from simultaneous onBlur + onKeyDown Enter
  3. `startEditing(uid, currentResult)`: Set editingUid to uid, draft to currentResult ?? '', savePendingRef to false
  4. `cancelEditing()`: Set editingUid to null, draft to ''
  5. `save(uid)`:
     - If savePendingRef.current is true, return (prevent double-save)
     - Set savePendingRef.current = true
     - Set isSaving = true
     - Call `setAnalysisResult(uid, draft.trim())`
     - On success: if response.success, call `onResultSaved?.(uid, draft.trim(), response.new_review_state)`, show `toast.success('Result saved')`, call cancelEditing()
     - On failure (response.success === false OR catch): show `toast.error('Failed to save result', { description: message })`, do NOT cancel editing (leave cell in edit mode so user can retry)
     - Finally: set isSaving = false, savePendingRef.current = false
  6. `handleKeyDown(e, uid)`:
     - Enter: e.preventDefault(), call save(uid)
     - Escape: e.preventDefault(), call cancelEditing()
     - Tab: e.preventDefault(), call save(uid), then after save resolves, find the next editable analysis uid and call startEditing on it. "Next editable" = the next analysis in the `analyses` array (by index) whose `review_state` is 'unassigned' or null. If none found after current, do nothing (stay in display mode).

  **Part B: Wire into AnalysisTable.tsx**

  1. Add `onResultSaved` callback prop to AnalysisTableProps:
     ```typescript
     interface AnalysisTableProps {
       analyses: SenaiteAnalysis[]
       analyteNameMap: Map<number, string>
       onResultSaved?: (uid: string, newResult: string, newReviewState: string | null) => void
     }
     ```

  2. Call useAnalysisEditing inside AnalysisTable:
     ```typescript
     const editing = useAnalysisEditing({ analyses, onResultSaved })
     ```

  3. Modify AnalysisRow to accept editing props and render click-to-edit on the Result cell:
     - Add props: `isEditing`, `draft`, `isSaving`, `onStartEditing`, `onCancelEditing`, `onSetDraft`, `onKeyDown`, `onSave`
     - The Result `<td>` cell:
       - If `isEditing`: render an `<input>` with the draft value, autoFocus, onKeyDown handler, disabled when isSaving. Show a small Spinner when saving. Input should be styled consistently: `text-sm font-mono h-7 px-2 py-1 rounded border border-input bg-background focus:outline-none focus:ring-2 focus:ring-ring`
       - If NOT editing AND analysis is editable (review_state is 'unassigned' or null): render the result value as a clickable element. On click, call `onStartEditing(uid, result)`. Show a subtle Pencil icon on hover (same pattern as EditableField.tsx — `text-muted-foreground/0 group-hover:text-muted-foreground`).
       - If NOT editing AND analysis is NOT editable (review_state is 'verified', 'to_be_verified', etc.): render as plain text (no click handler, no pencil icon). These cells are read-only.
     - The `onBlur` handler on the input: call save(uid) — but the savePendingRef guard prevents double-save if Enter was already pressed.

  4. In AnalysisTable, pass editing state to each AnalysisRow:
     ```typescript
     <AnalysisRow
       key={a.uid ?? `${a.title}-${i}`}
       analysis={a}
       analyteNameMap={analyteNameMap}
       isEditing={editing.editingUid === a.uid}
       draft={editing.draft}
       isSaving={editing.isSaving}
       onStartEditing={editing.startEditing}
       onCancelEditing={editing.cancelEditing}
       onSetDraft={editing.setDraft}
       onKeyDown={editing.handleKeyDown}
       onSave={editing.save}
     />
     ```

  5. Update SampleDetails.tsx to pass onResultSaved to AnalysisTable. The callback should update the local `data` state so the UI reflects the new result immediately (optimistic update):
     ```typescript
     const handleResultSaved = (uid: string, newResult: string, newReviewState: string | null) => {
       setData(prev => {
         if (!prev) return prev
         return {
           ...prev,
           analyses: prev.analyses.map(a =>
             a.uid === uid
               ? { ...a, result: newResult, review_state: newReviewState ?? a.review_state }
               : a
           ),
         }
       })
     }

     <AnalysisTable
       analyses={analyses}
       analyteNameMap={analyteNameMap}
       onResultSaved={handleResultSaved}
     />
     ```

  **Important constraints:**
  - Do NOT add `onBlur` if Tab is handled — Tab calls save which resolves then moves to next. The onBlur from Tab's focus-leave should be a no-op if save already ran (savePendingRef handles this).
  - Analyses without a `uid` should NOT be editable (show as plain text). This can happen with stale data before Plan 01 is deployed.
  - The input field should NOT have onBlur trigger save. Only Enter and Tab should save. Escape and clicking outside should cancel. This avoids the double-save problem entirely. The EditableField pattern uses onBlur-to-save but that causes issues — for table cells, explicit save via Enter/Tab is cleaner.

  Wait, re-reading EDIT-02: "Enter saves the value, Escape cancels edit, Tab moves to next editable cell." The simplest approach: Enter saves, Escape cancels, Tab saves-then-advances. Clicking outside (blur without Enter/Tab) should cancel. This is the cleanest UX for a table.

  So: onBlur should call cancelEditing() UNLESS save is already pending (savePendingRef). This way:
  - Enter -> save -> savePendingRef=true -> blur fires -> ref is true -> no-op -> save completes -> cancelEditing
  - Tab -> save -> savePendingRef=true -> blur fires -> ref is true -> no-op -> save completes -> advance to next
  - Click outside -> blur fires -> savePendingRef=false -> cancelEditing()
  - Escape -> cancelEditing() (explicit)
  </action>
  <verify>
  1. `npm run typecheck` passes
  2. `npm run lint` passes
  3. Hook file exists: `ls src/hooks/use-analysis-editing.ts`
  4. AnalysisTable imports the hook: grep for "useAnalysisEditing" in AnalysisTable.tsx
  5. SampleDetails passes onResultSaved: grep for "onResultSaved" in SampleDetails.tsx
  </verify>
  <done>
  - User can click a result cell on an unassigned analysis to edit inline (EDIT-01)
  - Enter saves, Escape cancels, Tab advances to next editable cell (EDIT-02)
  - Optimistic update shows new value immediately; rollback on error (EDIT-03)
  - Toast confirms success or shows error (EDIT-04)
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Inline result editing on analysis rows in Sample Details page. Data model updated with uid/keyword, backend endpoints created, AnalysisTable extracted, and click-to-edit wired with Enter/Escape/Tab keyboard handling.</what-built>
  <how-to-verify>
  1. Navigate to a Sample Details page with analyses (e.g. look up a sample in SENAITE tab)
  2. Verify the analyses table looks the same as before (no visual regression from component extraction)
  3. Find an analysis row with "Unassigned" status — the result cell should show "Pending" in italic
  4. Click the result cell — it should turn into an input field with a pencil icon hover effect
  5. Type a value (e.g. "95.5") and press Enter
  6. Verify: success toast appears, cell updates to show "95.5", and the value persists
  7. Click another unassigned result cell, type a value, then press Escape
  8. Verify: edit is cancelled, no toast, original value remains
  9. Click an unassigned result cell, type a value, then press Tab
  10. Verify: value saves, focus moves to the next unassigned result cell
  11. Try clicking a result cell on a "Verified" or "To Verify" row — it should NOT be editable
  12. Open browser Network tab and verify the lookup response includes "uid" and "keyword" fields on each analysis
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes
2. `npm run lint` passes
3. setAnalysisResult function exists in api.ts
4. useAnalysisEditing hook exists in src/hooks/
5. AnalysisTable uses the hook and renders editable cells
6. SampleDetails passes onResultSaved callback
7. Only unassigned analyses are editable
8. Enter saves, Escape cancels, Tab advances
9. Toast feedback on success and failure
</verification>

<success_criteria>
- EDIT-01: Click a result cell on an unassigned analysis to enter/edit the value inline
- EDIT-02: Enter saves, Escape cancels, Tab moves to next editable cell
- EDIT-03: Optimistic update with rollback on SENAITE error
- EDIT-04: Toast notification for success and failure
- Verified/to_be_verified analyses are read-only
- No double-save from blur + keydown race condition
</success_criteria>

<output>
After completion, create `.planning/phases/06-data-foundation-inline-editing/06-04-SUMMARY.md`
</output>
