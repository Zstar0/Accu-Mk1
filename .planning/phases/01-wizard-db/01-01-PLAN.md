---
phase: 01-wizard-db
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/models.py
  - backend/database.py
  - backend/main.py
autonomous: true

must_haves:
  truths:
    - "POST /wizard/sessions creates a session record in the database and returns a session ID"
    - "GET /wizard/sessions/{id} returns the session with all current measurements"
    - "POST /wizard/sessions/{id}/measurements records a raw weight and marks previous weight for the same step as is_current=False"
    - "POST /wizard/sessions/{id}/complete sets status to 'completed' and records completed_at"
    - "PATCH /wizard/sessions/{id} updates session fields (target params, peak_area)"
    - "GET /wizard/sessions returns a paginated list of sessions"
    - "All endpoints require JWT auth and return 401 without a valid token"
  artifacts:
    - path: "backend/models.py"
      provides: "WizardSession and WizardMeasurement SQLAlchemy 2.0 models"
      contains: "class WizardSession"
    - path: "backend/database.py"
      provides: "init_db() that creates wizard_sessions and wizard_measurements tables"
      contains: "wizard_sessions"
    - path: "backend/main.py"
      provides: "6 wizard REST endpoints"
      contains: "POST /wizard/sessions"
  key_links:
    - from: "backend/main.py"
      to: "backend/models.py"
      via: "import WizardSession, WizardMeasurement"
      pattern: "WizardSession|WizardMeasurement"
    - from: "backend/main.py WizardMeasurement insert"
      to: "WizardMeasurement.is_current"
      via: "re-weigh sets old is_current=False before inserting new"
      pattern: "is_current = False"
    - from: "POST /wizard/sessions"
      to: "CalibrationCurve.is_active"
      via: "auto-resolve active calibration curve on session create"
      pattern: "CalibrationCurve.*is_active"
---

<objective>
Add WizardSession and WizardMeasurement SQLAlchemy models, ensure new tables are created on startup via init_db(), and implement 6 REST endpoints for the wizard session lifecycle.

Purpose: Establishes the data persistence layer for the analysis wizard. Tech can start a session, record weights step by step, resume a session in progress, and mark it complete — all via API with JWT auth. This is the foundation every subsequent phase builds on.

Output: Two new DB models, two new tables, 6 authenticated REST endpoints, and Pydantic schemas for all request/response shapes.
</objective>

<execution_context>
@C:\Users\forre\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\forre\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-wizard-db/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WizardSession and WizardMeasurement models to models.py</name>
  <files>backend/models.py</files>
  <action>
Append two new model classes to the END of backend/models.py, after the last existing model. Use the exact SQLAlchemy 2.0 mapped_column style already used in the file.

```python
class WizardSession(Base):
    """
    Wizard session record. One session = one sample prep run.
    Status lifecycle: 'in_progress' | 'completed'

    declared_weight_mg is stored here (not as WizardMeasurement) because it is
    a manually entered text value, not a balance reading.
    """
    __tablename__ = "wizard_sessions"

    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    peptide_id: Mapped[int] = mapped_column(ForeignKey("peptides.id"), nullable=False)
    calibration_curve_id: Mapped[Optional[int]] = mapped_column(ForeignKey("calibration_curves.id"), nullable=True)
    status: Mapped[str] = mapped_column(String(50), default="in_progress", nullable=False)

    # Step 1: Sample info
    sample_id_label: Mapped[Optional[str]] = mapped_column(String(200), nullable=True)
    declared_weight_mg: Mapped[Optional[float]] = mapped_column(Float, nullable=True)

    # Step 1b: Target dilution parameters (manually entered)
    target_conc_ug_ml: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    target_total_vol_ul: Mapped[Optional[float]] = mapped_column(Float, nullable=True)

    # Step 4: HPLC results (entered after instrument run)
    peak_area: Mapped[Optional[float]] = mapped_column(Float, nullable=True)

    # Timestamps
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    completed_at: Mapped[Optional[datetime]] = mapped_column(DateTime, nullable=True)

    # Relationships
    measurements: Mapped[list["WizardMeasurement"]] = relationship(
        "WizardMeasurement", back_populates="session", cascade="all, delete-orphan"
    )
    peptide: Mapped["Peptide"] = relationship("Peptide")
    calibration_curve: Mapped[Optional["CalibrationCurve"]] = relationship("CalibrationCurve")

    def __repr__(self) -> str:
        return f"<WizardSession(id={self.id}, status='{self.status}')>"


class WizardMeasurement(Base):
    """
    Individual balance reading within a wizard session.
    Re-weighing inserts a NEW record and sets is_current=False on the old one.
    This preserves the full audit trail.

    step_key values (exactly these 5 strings):
      'stock_vial_empty_mg'       - Empty stock vial + cap
      'stock_vial_loaded_mg'      - Stock vial after adding diluent
      'dil_vial_empty_mg'         - Empty dilution vial + cap
      'dil_vial_with_diluent_mg'  - Dilution vial after adding diluent
      'dil_vial_final_mg'         - Dilution vial after adding stock aliquot

    source: 'manual' (Phase 1) | 'scale' (Phase 2 adds this)
    """
    __tablename__ = "wizard_measurements"

    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    session_id: Mapped[int] = mapped_column(ForeignKey("wizard_sessions.id"), nullable=False)
    step_key: Mapped[str] = mapped_column(String(50), nullable=False)
    weight_mg: Mapped[float] = mapped_column(Float, nullable=False)
    source: Mapped[str] = mapped_column(String(20), default="manual", nullable=False)
    is_current: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)
    recorded_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

    # Relationships
    session: Mapped["WizardSession"] = relationship("WizardSession", back_populates="measurements")

    def __repr__(self) -> str:
        return f"<WizardMeasurement(session={self.session_id}, step='{self.step_key}', weight={self.weight_mg})>"
```

No changes to existing models. No new imports needed — Float, Boolean, DateTime, ForeignKey, String, Optional, datetime, Mapped, mapped_column, relationship, Base are all already imported at the top of models.py.
  </action>
  <verify>
Run from the backend directory (with .venv activated):
```
python -c "from models import WizardSession, WizardMeasurement; print('OK')"
```
Must print OK with no import errors.
  </verify>
  <done>
`python -c "from models import WizardSession, WizardMeasurement; print('OK')"` prints OK. Both classes are defined with all required columns using mapped_column syntax.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create wizard_sessions and wizard_measurements tables via init_db()</name>
  <files>backend/database.py</files>
  <action>
The new tables (wizard_sessions, wizard_measurements) are created automatically by `Base.metadata.create_all(bind=engine)` in `init_db()` — no ALTER TABLE is needed for Phase 1. The only required change is confirming the models are imported before create_all() runs.

Read database.py. The existing `init_db()` already has `import models` which triggers all model registrations including the new ones. No code change is needed to database.py.

Verify by running init_db() and checking that both tables exist:

```python
# Quick verification script (run once, then discard)
import sys
sys.path.insert(0, '.')
from database import init_db, engine
from sqlalchemy import inspect
init_db()
inspector = inspect(engine)
tables = inspector.get_table_names()
print("wizard_sessions" in tables, "wizard_measurements" in tables)
```

If database.py currently has `import models` inside `init_db()` (confirmed it does), no edits are required. The task is complete when both tables exist after running the verification script.

Note: If for any reason the tables are not created, the fallback is to add explicit table creation after the create_all() call — but this should not be necessary since WizardSession and WizardMeasurement extend Base.
  </action>
  <verify>
```
cd backend && python -c "
from database import init_db, engine
from sqlalchemy import inspect
init_db()
tables = inspect(engine).get_table_names()
print('wizard_sessions:', 'wizard_sessions' in tables)
print('wizard_measurements:', 'wizard_measurements' in tables)
"
```
Both lines must print True.
  </verify>
  <done>
Both `wizard_sessions` and `wizard_measurements` appear in the SQLite table list after calling `init_db()`. The database.py file is unchanged (no edit needed) or minimally updated if the import was somehow missing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Pydantic schemas and 6 wizard endpoints to main.py</name>
  <files>backend/main.py</files>
  <action>
Append to the END of main.py (after line 4211). First add the import of new models, then the Pydantic schemas, then the helper function, then the 6 endpoints.

**Step A: Add model imports**

Find the existing models import line (line 23):
```python
from models import AuditLog, Settings, Job, Sample, Result, Peptide, CalibrationCurve, HPLCAnalysis, User, SharePointFileCache
```
Add `WizardSession, WizardMeasurement` to the end of that import. Result:
```python
from models import AuditLog, Settings, Job, Sample, Result, Peptide, CalibrationCurve, HPLCAnalysis, User, SharePointFileCache, WizardSession, WizardMeasurement
```

**Step B: Append schemas and endpoints at end of file**

Append the following block after the last line of main.py:

```python

# ─── Wizard Session Endpoints ──────────────────────────────────────────────────

# --- Pydantic schemas ---

VALID_STEP_KEYS = {
    "stock_vial_empty_mg",
    "stock_vial_loaded_mg",
    "dil_vial_empty_mg",
    "dil_vial_with_diluent_mg",
    "dil_vial_final_mg",
}


class WizardSessionCreate(BaseModel):
    """Schema for creating a new wizard session."""
    peptide_id: int
    sample_id_label: Optional[str] = None
    declared_weight_mg: Optional[float] = None  # mg; must be > 0 and < 5000 if provided
    target_conc_ug_ml: Optional[float] = None
    target_total_vol_ul: Optional[float] = None


class WizardSessionUpdate(BaseModel):
    """Schema for updating session fields (PATCH). All fields optional."""
    sample_id_label: Optional[str] = None
    declared_weight_mg: Optional[float] = None
    target_conc_ug_ml: Optional[float] = None
    target_total_vol_ul: Optional[float] = None
    peak_area: Optional[float] = None


class WizardMeasurementCreate(BaseModel):
    """Schema for recording a weight measurement."""
    step_key: str  # Must be one of VALID_STEP_KEYS
    weight_mg: float  # Raw balance reading in milligrams
    source: str = "manual"  # 'manual' | 'scale'


class WizardMeasurementResponse(BaseModel):
    """Schema for measurement response."""
    id: int
    session_id: int
    step_key: str
    weight_mg: float
    source: str
    is_current: bool
    recorded_at: datetime

    class Config:
        from_attributes = True


class WizardSessionResponse(BaseModel):
    """
    Full session response including current measurements and calculated values.
    Calculations are recalculated on demand — never stored in DB.
    Decimal values are converted to float at this boundary.
    """
    id: int
    peptide_id: int
    calibration_curve_id: Optional[int]
    status: str
    sample_id_label: Optional[str]
    declared_weight_mg: Optional[float]
    target_conc_ug_ml: Optional[float]
    target_total_vol_ul: Optional[float]
    peak_area: Optional[float]
    created_at: datetime
    updated_at: datetime
    completed_at: Optional[datetime]
    measurements: list[WizardMeasurementResponse] = []
    calculations: Optional[dict] = None  # Populated by _build_session_response()

    class Config:
        from_attributes = True


class WizardSessionListItem(BaseModel):
    """Lightweight session entry for list view."""
    id: int
    peptide_id: int
    status: str
    sample_id_label: Optional[str]
    declared_weight_mg: Optional[float]
    created_at: datetime
    updated_at: datetime
    completed_at: Optional[datetime]

    class Config:
        from_attributes = True


# --- Helper: build session response with inline calculations ---

def _build_session_response(session: WizardSession, db: Session) -> WizardSessionResponse:
    """
    Build a WizardSessionResponse from an ORM session object.
    Loads current measurements and triggers calculation.
    Decimal arithmetic happens inside calculations/wizard.py.
    float() conversion happens here at the response boundary.
    """
    from decimal import Decimal

    # Collect current measurements keyed by step_key
    current = {m.step_key: m.weight_mg for m in session.measurements if m.is_current}

    calcs: dict = {}

    # Stage 1: Stock Prep — requires declared_weight + 2 vial weights
    stock_empty = current.get("stock_vial_empty_mg")
    stock_loaded = current.get("stock_vial_loaded_mg")
    declared = session.declared_weight_mg

    stock_conc_d = None  # Decimal — used in subsequent stages

    if all(v is not None for v in [declared, stock_empty, stock_loaded]):
        try:
            from calculations.wizard import calc_stock_prep
            density = Decimal(str(session.peptide.diluent_density))
            sp = calc_stock_prep(
                Decimal(str(declared)),
                Decimal(str(stock_empty)),
                Decimal(str(stock_loaded)),
                density,
            )
            stock_conc_d = sp["stock_conc_ug_ml"]
            calcs["diluent_added_ml"] = float(sp["total_diluent_added_ml"])
            calcs["stock_conc_ug_ml"] = float(sp["stock_conc_ug_ml"])
        except Exception:
            pass  # Partial session — skip this stage

    # Stage 2: Required Volumes — requires Stage 1 + target params
    if stock_conc_d is not None and session.target_conc_ug_ml and session.target_total_vol_ul:
        try:
            from calculations.wizard import calc_required_volumes
            rv = calc_required_volumes(
                stock_conc_d,
                Decimal(str(session.target_conc_ug_ml)),
                Decimal(str(session.target_total_vol_ul)),
            )
            calcs["required_stock_vol_ul"] = float(rv["required_stock_vol_ul"])
            calcs["required_diluent_vol_ul"] = float(rv["required_diluent_vol_ul"])
        except Exception:
            pass

    # Stage 3: Actual Dilution — requires Stage 1 + 3 dilution vial weights
    dil_empty = current.get("dil_vial_empty_mg")
    dil_diluent = current.get("dil_vial_with_diluent_mg")
    dil_final = current.get("dil_vial_final_mg")

    actual_conc_d = None
    actual_total_d = None

    if stock_conc_d is not None and all(v is not None for v in [dil_empty, dil_diluent, dil_final]):
        try:
            from calculations.wizard import calc_actual_dilution
            density = Decimal(str(session.peptide.diluent_density))
            ad = calc_actual_dilution(
                stock_conc_d,
                Decimal(str(dil_empty)),
                Decimal(str(dil_diluent)),
                Decimal(str(dil_final)),
                density,
            )
            actual_conc_d = ad["actual_conc_ug_ml"]
            actual_total_d = ad["actual_total_vol_ul"]
            calcs["actual_diluent_vol_ul"] = float(ad["actual_diluent_vol_ul"])
            calcs["actual_stock_vol_ul"] = float(ad["actual_stock_vol_ul"])
            calcs["actual_total_vol_ul"] = float(ad["actual_total_vol_ul"])
            calcs["actual_conc_ug_ml"] = float(ad["actual_conc_ug_ml"])
        except Exception:
            pass

    # Stage 4: Results — requires Stage 3 + peak_area + calibration curve
    if actual_conc_d is not None and actual_total_d is not None and session.peak_area and session.calibration_curve_id:
        try:
            from calculations.wizard import calc_results
            cal = db.execute(
                select(CalibrationCurve).where(CalibrationCurve.id == session.calibration_curve_id)
            ).scalar_one_or_none()
            if cal:
                res = calc_results(
                    Decimal(str(session.peak_area)),
                    Decimal(str(cal.slope)),
                    Decimal(str(cal.intercept)),
                    actual_conc_d,
                    actual_total_d,
                )
                calcs["determined_conc_ug_ml"] = float(res["determined_conc_ug_ml"])
                calcs["peptide_mass_mg"] = float(res["peptide_mass_mg"])
                calcs["purity_pct"] = float(res["purity_pct"])
                calcs["dilution_factor"] = float(res["dilution_factor"])
        except Exception:
            pass

    # Build current measurements list (only is_current=True)
    current_measurements = [m for m in session.measurements if m.is_current]

    return WizardSessionResponse(
        id=session.id,
        peptide_id=session.peptide_id,
        calibration_curve_id=session.calibration_curve_id,
        status=session.status,
        sample_id_label=session.sample_id_label,
        declared_weight_mg=session.declared_weight_mg,
        target_conc_ug_ml=session.target_conc_ug_ml,
        target_total_vol_ul=session.target_total_vol_ul,
        peak_area=session.peak_area,
        created_at=session.created_at,
        updated_at=session.updated_at,
        completed_at=session.completed_at,
        measurements=[
            WizardMeasurementResponse.model_validate(m) for m in current_measurements
        ],
        calculations=calcs if calcs else None,
    )


# --- Endpoints ---

@app.post("/wizard/sessions", response_model=WizardSessionResponse, status_code=201)
async def create_wizard_session(
    data: WizardSessionCreate,
    db: Session = Depends(get_db),
    _current_user=Depends(get_current_user),
):
    """
    Start a new analysis wizard session (SESS-01).
    Auto-resolves the active calibration curve for the peptide.
    Returns 400 if no active calibration curve exists.
    Returns 404 if peptide not found.
    """
    peptide = db.execute(select(Peptide).where(Peptide.id == data.peptide_id)).scalar_one_or_none()
    if not peptide:
        raise HTTPException(status_code=404, detail=f"Peptide {data.peptide_id} not found")

    cal = db.execute(
        select(CalibrationCurve)
        .where(CalibrationCurve.peptide_id == data.peptide_id)
        .where(CalibrationCurve.is_active == True)
        .order_by(desc(CalibrationCurve.created_at))
        .limit(1)
    ).scalar_one_or_none()
    if not cal:
        raise HTTPException(
            status_code=400,
            detail=f"No active calibration curve found for peptide {data.peptide_id}. Activate a calibration curve before starting a session."
        )

    if data.declared_weight_mg is not None and not (0 < data.declared_weight_mg < 5000):
        raise HTTPException(status_code=422, detail="declared_weight_mg must be between 0 and 5000 mg")

    session = WizardSession(
        peptide_id=data.peptide_id,
        calibration_curve_id=cal.id,
        sample_id_label=data.sample_id_label,
        declared_weight_mg=data.declared_weight_mg,
        target_conc_ug_ml=data.target_conc_ug_ml,
        target_total_vol_ul=data.target_total_vol_ul,
    )
    db.add(session)
    db.commit()
    db.refresh(session)
    return _build_session_response(session, db)


@app.get("/wizard/sessions", response_model=list[WizardSessionListItem])
async def list_wizard_sessions(
    status: Optional[str] = None,
    peptide_id: Optional[int] = None,
    limit: int = 50,
    offset: int = 0,
    db: Session = Depends(get_db),
    _current_user=Depends(get_current_user),
):
    """
    List wizard sessions with optional filtering.
    Returns lightweight list items (no measurements, no calculations).
    """
    stmt = select(WizardSession).order_by(desc(WizardSession.created_at))
    if status:
        stmt = stmt.where(WizardSession.status == status)
    if peptide_id:
        stmt = stmt.where(WizardSession.peptide_id == peptide_id)
    stmt = stmt.offset(offset).limit(limit)
    sessions = db.execute(stmt).scalars().all()
    return sessions


@app.get("/wizard/sessions/{session_id}", response_model=WizardSessionResponse)
async def get_wizard_session(
    session_id: int,
    db: Session = Depends(get_db),
    _current_user=Depends(get_current_user),
):
    """
    Get a wizard session with all current measurements and recalculated values.
    Used for resuming an in-progress session (SESS-02).
    """
    session = db.execute(
        select(WizardSession).where(WizardSession.id == session_id)
    ).scalar_one_or_none()
    if not session:
        raise HTTPException(status_code=404, detail=f"Session {session_id} not found")
    return _build_session_response(session, db)


@app.patch("/wizard/sessions/{session_id}", response_model=WizardSessionResponse)
async def update_wizard_session(
    session_id: int,
    data: WizardSessionUpdate,
    db: Session = Depends(get_db),
    _current_user=Depends(get_current_user),
):
    """
    Update session fields (target params, peak_area, sample label, declared weight).
    Returns updated session with recalculated values.
    """
    session = db.execute(
        select(WizardSession).where(WizardSession.id == session_id)
    ).scalar_one_or_none()
    if not session:
        raise HTTPException(status_code=404, detail=f"Session {session_id} not found")
    if session.status == "completed":
        raise HTTPException(status_code=400, detail="Cannot update a completed session")

    update_data = data.model_dump(exclude_unset=True)
    if "declared_weight_mg" in update_data and update_data["declared_weight_mg"] is not None:
        if not (0 < update_data["declared_weight_mg"] < 5000):
            raise HTTPException(status_code=422, detail="declared_weight_mg must be between 0 and 5000 mg")

    for field, value in update_data.items():
        setattr(session, field, value)

    db.commit()
    db.refresh(session)
    return _build_session_response(session, db)


@app.post("/wizard/sessions/{session_id}/measurements", response_model=WizardSessionResponse, status_code=201)
async def record_measurement(
    session_id: int,
    data: WizardMeasurementCreate,
    db: Session = Depends(get_db),
    _current_user=Depends(get_current_user),
):
    """
    Record a weight for a wizard step. If a measurement for this step already exists,
    mark the old record as is_current=False (audit trail preserved) and insert a new one.
    Returns updated session with recalculated values.
    """
    session = db.execute(
        select(WizardSession).where(WizardSession.id == session_id)
    ).scalar_one_or_none()
    if not session:
        raise HTTPException(status_code=404, detail=f"Session {session_id} not found")
    if session.status == "completed":
        raise HTTPException(status_code=400, detail="Cannot add measurements to a completed session")

    if data.step_key not in VALID_STEP_KEYS:
        raise HTTPException(
            status_code=422,
            detail=f"Invalid step_key '{data.step_key}'. Must be one of: {sorted(VALID_STEP_KEYS)}"
        )
    if data.source not in ("manual", "scale"):
        raise HTTPException(status_code=422, detail="source must be 'manual' or 'scale'")

    # Mark existing current measurement for this step as superseded
    old = db.execute(
        select(WizardMeasurement)
        .where(WizardMeasurement.session_id == session_id)
        .where(WizardMeasurement.step_key == data.step_key)
        .where(WizardMeasurement.is_current == True)
    ).scalar_one_or_none()
    if old:
        old.is_current = False

    # Insert new measurement
    new_m = WizardMeasurement(
        session_id=session_id,
        step_key=data.step_key,
        weight_mg=data.weight_mg,
        source=data.source,
        is_current=True,
    )
    db.add(new_m)
    db.commit()
    db.refresh(session)
    return _build_session_response(session, db)


@app.post("/wizard/sessions/{session_id}/complete", response_model=WizardSessionResponse)
async def complete_wizard_session(
    session_id: int,
    db: Session = Depends(get_db),
    _current_user=Depends(get_current_user),
):
    """
    Mark a wizard session as complete (SESS-03).
    Sets status='completed' and records completed_at timestamp.
    Returns 400 if already completed.
    """
    session = db.execute(
        select(WizardSession).where(WizardSession.id == session_id)
    ).scalar_one_or_none()
    if not session:
        raise HTTPException(status_code=404, detail=f"Session {session_id} not found")
    if session.status == "completed":
        raise HTTPException(status_code=400, detail="Session is already completed")

    session.status = "completed"
    session.completed_at = datetime.utcnow()
    db.commit()
    db.refresh(session)
    return _build_session_response(session, db)
```
  </action>
  <verify>
Start the backend server and test all 6 endpoints:

```bash
# 1. Server starts without errors
cd backend && python -m uvicorn main:app --reload --port 8000
```

Then with the server running, run these curl tests (replace TOKEN with a valid JWT from POST /auth/login):

```bash
# Create session
curl -s -X POST http://localhost:8000/wizard/sessions \
  -H "Authorization: Bearer TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"peptide_id": 1, "sample_id_label": "P-0142", "declared_weight_mg": 50.0, "target_conc_ug_ml": 800.0, "target_total_vol_ul": 1500.0}' | python -m json.tool

# Get session
curl -s http://localhost:8000/wizard/sessions/1 -H "Authorization: Bearer TOKEN" | python -m json.tool

# Record measurement
curl -s -X POST http://localhost:8000/wizard/sessions/1/measurements \
  -H "Authorization: Bearer TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"step_key": "stock_vial_empty_mg", "weight_mg": 5501.68, "source": "manual"}' | python -m json.tool

# List sessions
curl -s http://localhost:8000/wizard/sessions -H "Authorization: Bearer TOKEN" | python -m json.tool

# Complete session
curl -s -X POST http://localhost:8000/wizard/sessions/1/complete -H "Authorization: Bearer TOKEN" | python -m json.tool
```

Verify:
- POST /wizard/sessions returns 201 with an `id` field
- GET /wizard/sessions/{id} returns the session with `measurements: []` and `calculations: null`
- POST measurements returns session with the measurement in `measurements` array and `is_current: true`
- GET /wizard/sessions returns array
- POST /complete returns session with `status: "completed"` and non-null `completed_at`
- All endpoints return 401 without Authorization header
  </verify>
  <done>
All 6 endpoints respond correctly. Server starts without import errors. A newly created session has `status: "in_progress"`, a recording endpoint correctly supersedes old measurements, and complete endpoint sets `status: "completed"`. Auth is required on all endpoints.
  </done>
</task>

</tasks>

<verification>
After all three tasks:

1. `python -c "from models import WizardSession, WizardMeasurement; print('models OK')"` passes
2. `python -c "from database import init_db, engine; from sqlalchemy import inspect; init_db(); t = inspect(engine).get_table_names(); print('tables OK:', 'wizard_sessions' in t and 'wizard_measurements' in t)"` prints `tables OK: True`
3. Backend starts with `uvicorn main:app` without any import or syntax errors
4. Full CRUD cycle works: create session -> record 2+ measurements for the same step (re-weigh) -> GET session shows only is_current=True measurement -> complete session
</verification>

<success_criteria>
- WizardSession model exists in models.py with all required columns (mapped_column style)
- WizardMeasurement model exists in models.py with step_key, weight_mg, source, is_current columns
- wizard_sessions and wizard_measurements tables exist in the SQLite database after startup
- POST /wizard/sessions returns 201 with session ID; auto-resolves calibration curve; returns 400 if none active
- GET /wizard/sessions/{id} returns session with current measurements and partial calculations
- POST /wizard/sessions/{id}/measurements records weight and archives previous measurement with is_current=False
- PATCH /wizard/sessions/{id} updates scalar fields and returns recalculated response
- POST /wizard/sessions/{id}/complete sets status=completed and records completed_at
- GET /wizard/sessions returns paginated list
- All endpoints require JWT auth
</success_criteria>

<output>
After completion, create `.planning/phases/01-wizard-db/01-01-SUMMARY.md` using the summary template.
</output>
