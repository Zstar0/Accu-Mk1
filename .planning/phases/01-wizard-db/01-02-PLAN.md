---
phase: 01-wizard-db
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - backend/calculations/wizard.py
  - backend/tests/test_wizard_calculations.py
autonomous: true

must_haves:
  truths:
    - "calc_stock_prep() returns correct diluent_mass_mg, total_diluent_added_ml, and stock_conc_ug_ml for known lab values"
    - "calc_required_volumes() returns correct required_stock_vol_ul and required_diluent_vol_ul that sum to target_total_vol_ul"
    - "calc_actual_dilution() returns actual_diluent_vol_ul, actual_stock_vol_ul, actual_total_vol_ul, and actual_conc_ug_ml from three vial weights"
    - "calc_results() returns determined_conc_ug_ml, peptide_mass_mg, purity_pct, and dilution_factor from peak area and calibration params"
    - "All arithmetic uses Decimal internally — no float intermediate values"
    - "No Decimal values escape the module boundary — functions accept and return Decimal, callers convert to float"
    - "Tests pass with the verified lab Excel values as inputs"
  artifacts:
    - path: "backend/calculations/wizard.py"
      provides: "Four pure Decimal calculation functions for all wizard stages"
      contains: "def calc_stock_prep"
    - path: "backend/tests/test_wizard_calculations.py"
      provides: "Unit tests with verified lab values for all 4 functions"
      contains: "def test_calc_stock_prep"
  key_links:
    - from: "backend/calculations/wizard.py"
      to: "decimal.Decimal"
      via: "from decimal import Decimal, getcontext"
      pattern: "from decimal import Decimal"
    - from: "backend/main.py _build_session_response"
      to: "backend/calculations/wizard.py"
      via: "from calculations.wizard import calc_stock_prep, ..."
      pattern: "from calculations.wizard import"
---

<objective>
Create backend/calculations/wizard.py with four pure Decimal calculation functions covering all wizard stages, and backend/tests/test_wizard_calculations.py with unit tests verified against the lab Excel reference values.

Purpose: The calculation engine is the heart of the wizard. Using TDD ensures the formulas are correct BEFORE they are wired into the API response helper in Plan 01-01 (_build_session_response). A failing test against known lab values is the single source of truth for formula correctness.

Output: wizard.py (pure functions, no DB/FastAPI dependencies) and test_wizard_calculations.py (pytest unit tests passing with verified lab values).
</objective>

<execution_context>
@C:\Users\forre\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\forre\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-wizard-db/01-RESEARCH.md
@.planning/STATE.md
</context>

<feature>
  <name>Wizard Decimal Calculation Engine</name>
  <files>backend/calculations/wizard.py, backend/tests/test_wizard_calculations.py</files>
  <behavior>
Four pure functions. All inputs and outputs are Decimal. No side effects. No imports from the rest of the codebase.

Verified lab Excel values (from RESEARCH.md — tested 2026-02-19):

Stock Prep inputs:
  declared_weight_mg = Decimal("50")
  stock_vial_empty_mg = Decimal("5501.68")
  stock_vial_loaded_mg = Decimal("8505.75")
  diluent_density = Decimal("997.1")

Stock Prep expected outputs:
  diluent_mass_mg = 3004.07
  total_diluent_added_ml = 3.01280... (≈ 3.0128)
  stock_conc_ug_ml = 16595.82... (≈ 16595.82)

Required Volumes inputs:
  stock_conc_ug_ml = (from above)
  target_conc_ug_ml = Decimal("800")
  target_total_vol_ul = Decimal("1500")

Required Volumes expected outputs:
  required_stock_vol_ul = 72.31... (≈ 72.31)
  required_diluent_vol_ul = 1427.69... (≈ 1427.69)
  required_stock_vol_ul + required_diluent_vol_ul == target_total_vol_ul

Actual Dilution: uses 3 measured vial weights + stock_conc. Returns actual volumes and actual concentration.

Results: uses peak_area, calibration slope/intercept, actual_conc, actual_total_vol. Returns determined_conc, peptide_mass, purity_pct, dilution_factor.

TDD cases:
  expect(calc_stock_prep(D("50"), D("5501.68"), D("8505.75"), D("997.1"))["diluent_mass_mg"]) == D("3004.07")
  expect(round(float(result["stock_conc_ug_ml"]), 2)) == 16595.82
  expect(round(float(required["required_stock_vol_ul"]), 2)) == 72.31
  expect(required["required_stock_vol_ul"] + required["required_diluent_vol_ul"]) == D("1500")
  (within Decimal precision tolerance)
  </behavior>
  <implementation>
Four standalone functions in wizard.py:

1. calc_stock_prep(declared_weight_mg, stock_vial_empty_mg, stock_vial_loaded_mg, diluent_density) -> dict
   diluent_mass_mg = stock_vial_loaded_mg - stock_vial_empty_mg
   total_diluent_added_ml = diluent_mass_mg / diluent_density
   stock_conc_ug_ml = (declared_weight_mg * Decimal("1000")) / total_diluent_added_ml
   returns: {diluent_mass_mg, total_diluent_added_ml, stock_conc_ug_ml}

2. calc_required_volumes(stock_conc_ug_ml, target_conc_ug_ml, target_total_vol_ul) -> dict
   required_stock_vol_ul = target_total_vol_ul * (target_conc_ug_ml / stock_conc_ug_ml)
   required_diluent_vol_ul = target_total_vol_ul - required_stock_vol_ul
   returns: {required_stock_vol_ul, required_diluent_vol_ul}

3. calc_actual_dilution(stock_conc_ug_ml, dil_vial_empty_mg, dil_vial_with_diluent_mg, dil_vial_final_mg, diluent_density) -> dict
   actual_diluent_mass_mg = dil_vial_with_diluent_mg - dil_vial_empty_mg
   actual_diluent_vol_ul = actual_diluent_mass_mg / diluent_density * Decimal("1000")
   actual_stock_mass_mg = dil_vial_final_mg - dil_vial_with_diluent_mg
   actual_stock_vol_ul = actual_stock_mass_mg / diluent_density * Decimal("1000")
   actual_total_vol_ul = actual_diluent_vol_ul + actual_stock_vol_ul
   actual_conc_ug_ml = stock_conc_ug_ml * actual_stock_vol_ul / actual_total_vol_ul
   returns: {actual_diluent_vol_ul, actual_stock_vol_ul, actual_total_vol_ul, actual_conc_ug_ml}

4. calc_results(peak_area, calibration_slope, calibration_intercept, actual_conc_ug_ml, actual_total_vol_ul) -> dict
   determined_conc_ug_ml = (peak_area - calibration_intercept) / calibration_slope
   peptide_mass_mg = determined_conc_ug_ml * actual_total_vol_ul / Decimal("1000")
   purity_pct = (determined_conc_ug_ml / actual_conc_ug_ml) * Decimal("100")
   dilution_factor = actual_total_vol_ul / actual_stock_vol_ul
   NOTE: calc_results does not have actual_stock_vol_ul in scope — pass it as a parameter or
   compute dilution_factor as actual_total_vol_ul / (actual_total_vol_ul - actual_diluent_vol_ul).
   Simplest correct approach: add actual_stock_vol_ul as a required parameter to calc_results.
   returns: {determined_conc_ug_ml, peptide_mass_mg, purity_pct, dilution_factor}
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>RED — Write failing tests for all four calculation functions</name>
  <files>backend/tests/test_wizard_calculations.py</files>
  <action>
Create the directory and test file. The file must import from calculations.wizard, which does not exist yet, so the import itself will fail — that is the correct RED state.

First create the tests directory if it does not exist:
```bash
mkdir -p backend/tests
touch backend/tests/__init__.py
```

Create backend/tests/test_wizard_calculations.py:

```python
"""
Unit tests for the wizard Decimal calculation engine.

Reference values verified against lab Excel workbook on 2026-02-19.
All comparisons use round(..., N) to handle trailing Decimal precision.
"""

import pytest
from decimal import Decimal, getcontext

getcontext().prec = 28

# Imports will fail (RED) until wizard.py is created
from calculations.wizard import (
    calc_stock_prep,
    calc_required_volumes,
    calc_actual_dilution,
    calc_results,
)


# ─── Shared test fixtures ──────────────────────────────────────────────────────

DILUENT_DENSITY = Decimal("997.1")

# Stock prep inputs (from lab Excel)
DECLARED_WEIGHT_MG = Decimal("50")
STOCK_VIAL_EMPTY = Decimal("5501.68")
STOCK_VIAL_LOADED = Decimal("8505.75")

# Target dilution inputs
TARGET_CONC = Decimal("800")
TARGET_TOTAL_VOL = Decimal("1500")

# Dilution vial inputs (representative values)
DIL_VIAL_EMPTY = Decimal("12000.00")
DIL_VIAL_WITH_DILUENT = Decimal("13427.69")   # +1427.69 mg diluent
DIL_VIAL_FINAL = Decimal("13499.99")           # +72.30 mg stock

# Calibration curve params (representative values)
CAL_SLOPE = Decimal("50000")
CAL_INTERCEPT = Decimal("1000")
PEAK_AREA = Decimal("41980601")   # gives determined_conc ≈ 839.2 µg/mL


# ─── calc_stock_prep tests ────────────────────────────────────────────────────

class TestCalcStockPrep:
    """Tests for stock preparation calculations."""

    def test_diluent_mass(self):
        """diluent_mass = loaded - empty vial"""
        result = calc_stock_prep(DECLARED_WEIGHT_MG, STOCK_VIAL_EMPTY, STOCK_VIAL_LOADED, DILUENT_DENSITY)
        assert result["diluent_mass_mg"] == Decimal("3004.07")

    def test_total_diluent_added_ml(self):
        """total_diluent_added_ml = diluent_mass / density (verified: 3.0128 mL)"""
        result = calc_stock_prep(DECLARED_WEIGHT_MG, STOCK_VIAL_EMPTY, STOCK_VIAL_LOADED, DILUENT_DENSITY)
        assert round(float(result["total_diluent_added_ml"]), 4) == 3.0128

    def test_stock_concentration(self):
        """stock_conc = declared_weight_mg * 1000 / total_diluent_ml (verified: 16595.82 µg/mL)"""
        result = calc_stock_prep(DECLARED_WEIGHT_MG, STOCK_VIAL_EMPTY, STOCK_VIAL_LOADED, DILUENT_DENSITY)
        assert round(float(result["stock_conc_ug_ml"]), 2) == 16595.82

    def test_all_keys_present(self):
        """Result dict contains all expected keys."""
        result = calc_stock_prep(DECLARED_WEIGHT_MG, STOCK_VIAL_EMPTY, STOCK_VIAL_LOADED, DILUENT_DENSITY)
        assert set(result.keys()) == {"diluent_mass_mg", "total_diluent_added_ml", "stock_conc_ug_ml"}

    def test_returns_decimal_types(self):
        """All returned values must be Decimal — no float leakage."""
        result = calc_stock_prep(DECLARED_WEIGHT_MG, STOCK_VIAL_EMPTY, STOCK_VIAL_LOADED, DILUENT_DENSITY)
        for key, val in result.items():
            assert isinstance(val, Decimal), f"{key} is {type(val)}, expected Decimal"

    def test_zero_diluent_raises(self):
        """Raises error when loaded == empty (no diluent added — division by zero in next step)."""
        # calc_stock_prep itself won't divide by zero (diluent_mass != 0 scenario),
        # but if loaded == empty, diluent_mass = 0 → stock_conc = declared * 1000 / 0 → ZeroDivisionError
        with pytest.raises(Exception):
            calc_stock_prep(DECLARED_WEIGHT_MG, STOCK_VIAL_EMPTY, STOCK_VIAL_EMPTY, DILUENT_DENSITY)


# ─── calc_required_volumes tests ─────────────────────────────────────────────

class TestCalcRequiredVolumes:
    """Tests for required dilution volume calculations."""

    @pytest.fixture
    def stock_conc(self):
        result = calc_stock_prep(DECLARED_WEIGHT_MG, STOCK_VIAL_EMPTY, STOCK_VIAL_LOADED, DILUENT_DENSITY)
        return result["stock_conc_ug_ml"]

    def test_required_stock_vol(self, stock_conc):
        """required_stock_vol = target_total * (target_conc / stock_conc) (verified: 72.31 µL)"""
        result = calc_required_volumes(stock_conc, TARGET_CONC, TARGET_TOTAL_VOL)
        assert round(float(result["required_stock_vol_ul"]), 2) == 72.31

    def test_required_diluent_vol(self, stock_conc):
        """required_diluent_vol = target_total - stock_vol (verified: 1427.69 µL)"""
        result = calc_required_volumes(stock_conc, TARGET_CONC, TARGET_TOTAL_VOL)
        assert round(float(result["required_diluent_vol_ul"]), 2) == 1427.69

    def test_volumes_sum_to_target(self, stock_conc):
        """Invariant: stock_vol + diluent_vol == target_total_vol (exact Decimal equality)."""
        result = calc_required_volumes(stock_conc, TARGET_CONC, TARGET_TOTAL_VOL)
        total = result["required_stock_vol_ul"] + result["required_diluent_vol_ul"]
        assert round(float(total), 6) == float(TARGET_TOTAL_VOL)

    def test_all_keys_present(self, stock_conc):
        result = calc_required_volumes(stock_conc, TARGET_CONC, TARGET_TOTAL_VOL)
        assert set(result.keys()) == {"required_stock_vol_ul", "required_diluent_vol_ul"}

    def test_returns_decimal_types(self, stock_conc):
        result = calc_required_volumes(stock_conc, TARGET_CONC, TARGET_TOTAL_VOL)
        for key, val in result.items():
            assert isinstance(val, Decimal), f"{key} is {type(val)}, expected Decimal"


# ─── calc_actual_dilution tests ───────────────────────────────────────────────

class TestCalcActualDilution:
    """Tests for actual dilution volume and concentration calculations."""

    @pytest.fixture
    def stock_conc(self):
        result = calc_stock_prep(DECLARED_WEIGHT_MG, STOCK_VIAL_EMPTY, STOCK_VIAL_LOADED, DILUENT_DENSITY)
        return result["stock_conc_ug_ml"]

    def test_actual_diluent_vol(self, stock_conc):
        """actual_diluent_vol_ul = (with_diluent - empty) / density * 1000"""
        result = calc_actual_dilution(
            stock_conc, DIL_VIAL_EMPTY, DIL_VIAL_WITH_DILUENT, DIL_VIAL_FINAL, DILUENT_DENSITY
        )
        # (13427.69 - 12000.00) / 997.1 * 1000 = 1427.69... / 997.1 * 1000 = 1431.77... µL
        assert result["actual_diluent_vol_ul"] > Decimal("0")

    def test_actual_stock_vol(self, stock_conc):
        """actual_stock_vol_ul = (final - with_diluent) / density * 1000"""
        result = calc_actual_dilution(
            stock_conc, DIL_VIAL_EMPTY, DIL_VIAL_WITH_DILUENT, DIL_VIAL_FINAL, DILUENT_DENSITY
        )
        assert result["actual_stock_vol_ul"] > Decimal("0")

    def test_total_vol_is_sum(self, stock_conc):
        """actual_total_vol = diluent_vol + stock_vol (invariant)."""
        result = calc_actual_dilution(
            stock_conc, DIL_VIAL_EMPTY, DIL_VIAL_WITH_DILUENT, DIL_VIAL_FINAL, DILUENT_DENSITY
        )
        expected_total = result["actual_diluent_vol_ul"] + result["actual_stock_vol_ul"]
        assert result["actual_total_vol_ul"] == expected_total

    def test_actual_conc_is_positive(self, stock_conc):
        """actual_conc must be > 0 and < stock_conc (dilution reduces concentration)."""
        result = calc_actual_dilution(
            stock_conc, DIL_VIAL_EMPTY, DIL_VIAL_WITH_DILUENT, DIL_VIAL_FINAL, DILUENT_DENSITY
        )
        assert Decimal("0") < result["actual_conc_ug_ml"] < stock_conc

    def test_all_keys_present(self, stock_conc):
        result = calc_actual_dilution(
            stock_conc, DIL_VIAL_EMPTY, DIL_VIAL_WITH_DILUENT, DIL_VIAL_FINAL, DILUENT_DENSITY
        )
        assert set(result.keys()) == {
            "actual_diluent_vol_ul", "actual_stock_vol_ul",
            "actual_total_vol_ul", "actual_conc_ug_ml"
        }

    def test_returns_decimal_types(self, stock_conc):
        result = calc_actual_dilution(
            stock_conc, DIL_VIAL_EMPTY, DIL_VIAL_WITH_DILUENT, DIL_VIAL_FINAL, DILUENT_DENSITY
        )
        for key, val in result.items():
            assert isinstance(val, Decimal), f"{key} is {type(val)}, expected Decimal"


# ─── calc_results tests ───────────────────────────────────────────────────────

class TestCalcResults:
    """Tests for HPLC results calculations."""

    @pytest.fixture
    def actual_vals(self):
        """Provide realistic actual dilution outputs."""
        stock_conc = calc_stock_prep(
            DECLARED_WEIGHT_MG, STOCK_VIAL_EMPTY, STOCK_VIAL_LOADED, DILUENT_DENSITY
        )["stock_conc_ug_ml"]
        return calc_actual_dilution(
            stock_conc, DIL_VIAL_EMPTY, DIL_VIAL_WITH_DILUENT, DIL_VIAL_FINAL, DILUENT_DENSITY
        )

    def test_determined_conc(self, actual_vals):
        """determined_conc = (peak_area - intercept) / slope"""
        result = calc_results(
            CAL_SLOPE, CAL_INTERCEPT, PEAK_AREA,
            actual_vals["actual_conc_ug_ml"],
            actual_vals["actual_total_vol_ul"],
            actual_vals["actual_stock_vol_ul"],
        )
        # (41980601 - 1000) / 50000 = 839.19202
        expected = (PEAK_AREA - CAL_INTERCEPT) / CAL_SLOPE
        assert round(float(result["determined_conc_ug_ml"]), 2) == round(float(expected), 2)

    def test_peptide_mass_mg(self, actual_vals):
        """peptide_mass_mg = determined_conc * total_vol / 1000"""
        result = calc_results(
            CAL_SLOPE, CAL_INTERCEPT, PEAK_AREA,
            actual_vals["actual_conc_ug_ml"],
            actual_vals["actual_total_vol_ul"],
            actual_vals["actual_stock_vol_ul"],
        )
        assert result["peptide_mass_mg"] > Decimal("0")

    def test_purity_pct(self, actual_vals):
        """purity_pct = (determined_conc / actual_conc) * 100; value in range (0, 200)"""
        result = calc_results(
            CAL_SLOPE, CAL_INTERCEPT, PEAK_AREA,
            actual_vals["actual_conc_ug_ml"],
            actual_vals["actual_total_vol_ul"],
            actual_vals["actual_stock_vol_ul"],
        )
        assert Decimal("0") < result["purity_pct"] < Decimal("200")

    def test_dilution_factor(self, actual_vals):
        """dilution_factor = actual_total_vol / actual_stock_vol; must be >= 1"""
        result = calc_results(
            CAL_SLOPE, CAL_INTERCEPT, PEAK_AREA,
            actual_vals["actual_conc_ug_ml"],
            actual_vals["actual_total_vol_ul"],
            actual_vals["actual_stock_vol_ul"],
        )
        assert result["dilution_factor"] >= Decimal("1")

    def test_all_keys_present(self, actual_vals):
        result = calc_results(
            CAL_SLOPE, CAL_INTERCEPT, PEAK_AREA,
            actual_vals["actual_conc_ug_ml"],
            actual_vals["actual_total_vol_ul"],
            actual_vals["actual_stock_vol_ul"],
        )
        assert set(result.keys()) == {
            "determined_conc_ug_ml", "peptide_mass_mg", "purity_pct", "dilution_factor"
        }

    def test_returns_decimal_types(self, actual_vals):
        result = calc_results(
            CAL_SLOPE, CAL_INTERCEPT, PEAK_AREA,
            actual_vals["actual_conc_ug_ml"],
            actual_vals["actual_total_vol_ul"],
            actual_vals["actual_stock_vol_ul"],
        )
        for key, val in result.items():
            assert isinstance(val, Decimal), f"{key} is {type(val)}, expected Decimal"
```

Run the tests from the backend directory:
```bash
cd backend && python -m pytest tests/test_wizard_calculations.py -v 2>&1 | head -30
```

Expected: ImportError or ModuleNotFoundError on `from calculations.wizard import ...` — this is the correct RED state. Commit:
```bash
git add backend/tests/test_wizard_calculations.py backend/tests/__init__.py
git commit -m "test(01-02): add failing tests for wizard calculation engine"
```
  </action>
  <verify>
```bash
cd backend && python -m pytest tests/test_wizard_calculations.py -v 2>&1 | head -20
```
Must show ERRORS (not PASSED) — specifically ImportError because calculations/wizard.py does not exist yet.
  </verify>
  <done>
pytest reports import errors when running test_wizard_calculations.py. The test file is committed to git.
  </done>
</task>

<task type="auto">
  <name>GREEN — Implement calculations/wizard.py to make all tests pass</name>
  <files>backend/calculations/wizard.py</files>
  <action>
Create backend/calculations/wizard.py with four pure Decimal functions. No imports from the rest of the codebase. No side effects.

NOTE: The test for `calc_results` passes `CAL_SLOPE, CAL_INTERCEPT, PEAK_AREA` (slope first), so match that parameter order in the function signature.

```python
"""
Wizard sample prep calculation engine.

All arithmetic uses Decimal internally. No float intermediate values.
Callers must convert inputs from float with Decimal(str(value)).
Callers must convert outputs to float with float(value) at the API boundary.

Four calculation stages map to the 5-step wizard:
  Stage 1 (Stock Prep):       calc_stock_prep()
  Stage 2 (Required Volumes): calc_required_volumes()
  Stage 3 (Actual Dilution):  calc_actual_dilution()
  Stage 4 (Results):          calc_results()
"""

from decimal import Decimal, getcontext

# 28-digit precision — sufficient for all chained wizard calculations
getcontext().prec = 28


def calc_stock_prep(
    declared_weight_mg: Decimal,
    stock_vial_empty_mg: Decimal,
    stock_vial_loaded_mg: Decimal,
    diluent_density: Decimal,
) -> dict:
    """
    Stage 1: Calculate stock preparation values.

    Args:
        declared_weight_mg:  Supplier-declared peptide weight (mg). Text input by tech.
        stock_vial_empty_mg: Empty stock vial + cap weight (mg). Balance reading.
        stock_vial_loaded_mg: Stock vial weight after adding diluent (mg). Balance reading.
        diluent_density:     Diluent density (mg/mL). From Peptide.diluent_density.

    Returns dict with Decimal values:
        diluent_mass_mg:        Mass of diluent added to stock vial (mg)
        total_diluent_added_ml: Volume of diluent added (mL)
        stock_conc_ug_ml:       Stock solution concentration (µg/mL)

    Verified against lab Excel: declared=50mg, empty=5501.68mg, loaded=8505.75mg →
        diluent_mass=3004.07mg, total_diluent=3.0128mL, stock_conc=16595.82µg/mL
    """
    diluent_mass_mg = stock_vial_loaded_mg - stock_vial_empty_mg
    total_diluent_added_ml = diluent_mass_mg / diluent_density
    stock_conc_ug_ml = (declared_weight_mg * Decimal("1000")) / total_diluent_added_ml
    return {
        "diluent_mass_mg": diluent_mass_mg,
        "total_diluent_added_ml": total_diluent_added_ml,
        "stock_conc_ug_ml": stock_conc_ug_ml,
    }


def calc_required_volumes(
    stock_conc_ug_ml: Decimal,
    target_conc_ug_ml: Decimal,
    target_total_vol_ul: Decimal,
) -> dict:
    """
    Stage 2: Calculate required stock and diluent volumes to hit target concentration.

    Args:
        stock_conc_ug_ml:    Stock solution concentration from Stage 1 (µg/mL)
        target_conc_ug_ml:   Desired final concentration (µg/mL). Tech input.
        target_total_vol_ul: Desired total final volume (µL). Tech input.

    Returns dict with Decimal values:
        required_stock_vol_ul:   Volume of stock solution to pipette (µL)
        required_diluent_vol_ul: Volume of diluent to add (µL)

    Invariant: required_stock_vol_ul + required_diluent_vol_ul == target_total_vol_ul

    Verified: stock_conc=16595.82, target_conc=800, target_vol=1500 →
        stock_vol=72.31µL, diluent_vol=1427.69µL
    """
    required_stock_vol_ul = target_total_vol_ul * (target_conc_ug_ml / stock_conc_ug_ml)
    required_diluent_vol_ul = target_total_vol_ul - required_stock_vol_ul
    return {
        "required_stock_vol_ul": required_stock_vol_ul,
        "required_diluent_vol_ul": required_diluent_vol_ul,
    }


def calc_actual_dilution(
    stock_conc_ug_ml: Decimal,
    dil_vial_empty_mg: Decimal,
    dil_vial_with_diluent_mg: Decimal,
    dil_vial_final_mg: Decimal,
    diluent_density: Decimal,
) -> dict:
    """
    Stage 3: Calculate actual dilution volumes and concentration from measured vial weights.

    Tech weighs the dilution vial at 3 points:
      1. Empty vial (dil_vial_empty_mg)
      2. After adding diluent (dil_vial_with_diluent_mg)
      3. After adding stock aliquot (dil_vial_final_mg)

    Args:
        stock_conc_ug_ml:         Stock concentration from Stage 1 (µg/mL)
        dil_vial_empty_mg:        Empty dilution vial + cap (mg). Balance reading.
        dil_vial_with_diluent_mg: Dilution vial after adding diluent (mg). Balance reading.
        dil_vial_final_mg:        Dilution vial after adding stock aliquot (mg). Balance reading.
        diluent_density:          Diluent density (mg/mL). From Peptide.diluent_density.

    Returns dict with Decimal values:
        actual_diluent_vol_ul: Actual diluent volume added (µL)
        actual_stock_vol_ul:   Actual stock volume pipetted (µL)
        actual_total_vol_ul:   Actual total solution volume (µL)
        actual_conc_ug_ml:     Actual final concentration (µg/mL)
    """
    actual_diluent_mass_mg = dil_vial_with_diluent_mg - dil_vial_empty_mg
    actual_diluent_vol_ul = actual_diluent_mass_mg / diluent_density * Decimal("1000")

    actual_stock_mass_mg = dil_vial_final_mg - dil_vial_with_diluent_mg
    actual_stock_vol_ul = actual_stock_mass_mg / diluent_density * Decimal("1000")

    actual_total_vol_ul = actual_diluent_vol_ul + actual_stock_vol_ul
    actual_conc_ug_ml = stock_conc_ug_ml * actual_stock_vol_ul / actual_total_vol_ul

    return {
        "actual_diluent_vol_ul": actual_diluent_vol_ul,
        "actual_stock_vol_ul": actual_stock_vol_ul,
        "actual_total_vol_ul": actual_total_vol_ul,
        "actual_conc_ug_ml": actual_conc_ug_ml,
    }


def calc_results(
    calibration_slope: Decimal,
    calibration_intercept: Decimal,
    peak_area: Decimal,
    actual_conc_ug_ml: Decimal,
    actual_total_vol_ul: Decimal,
    actual_stock_vol_ul: Decimal,
) -> dict:
    """
    Stage 4: Calculate HPLC results from peak area and calibration curve.

    Run after tech enters the peak area from the HPLC instrument report.

    Args:
        calibration_slope:      Slope from active CalibrationCurve (area/conc)
        calibration_intercept:  Intercept from active CalibrationCurve
        peak_area:              Peak area reading from HPLC instrument
        actual_conc_ug_ml:      Actual concentration from Stage 3 (µg/mL)
        actual_total_vol_ul:    Actual total volume from Stage 3 (µL)
        actual_stock_vol_ul:    Actual stock volume from Stage 3 (µL) — used for dilution factor

    Returns dict with Decimal values:
        determined_conc_ug_ml: Back-calculated concentration from HPLC peak (µg/mL)
        peptide_mass_mg:        Total peptide mass in the dilution vial (mg)
        purity_pct:             Purity percentage vs actual concentration (%)
        dilution_factor:        actual_total_vol / actual_stock_vol (dimensionless)
    """
    determined_conc_ug_ml = (peak_area - calibration_intercept) / calibration_slope
    peptide_mass_mg = determined_conc_ug_ml * actual_total_vol_ul / Decimal("1000")
    purity_pct = (determined_conc_ug_ml / actual_conc_ug_ml) * Decimal("100")
    dilution_factor = actual_total_vol_ul / actual_stock_vol_ul

    return {
        "determined_conc_ug_ml": determined_conc_ug_ml,
        "peptide_mass_mg": peptide_mass_mg,
        "purity_pct": purity_pct,
        "dilution_factor": dilution_factor,
    }
```

After creating the file, run tests:
```bash
cd backend && python -m pytest tests/test_wizard_calculations.py -v
```

All tests must pass. If any fail, fix the implementation — do NOT change the tests to make them pass.

IMPORTANT: The test file calls `calc_results` with positional args as `(CAL_SLOPE, CAL_INTERCEPT, PEAK_AREA, actual_conc, actual_total, actual_stock)`. The function signature must match this order exactly: `calc_results(calibration_slope, calibration_intercept, peak_area, actual_conc_ug_ml, actual_total_vol_ul, actual_stock_vol_ul)`.

ALSO IMPORTANT: The `_build_session_response` helper in Plan 01-01 calls `calc_results` as:
```python
calc_results(
    Decimal(str(session.peak_area)),
    Decimal(str(cal.slope)),
    Decimal(str(cal.intercept)),
    actual_conc_d,
    actual_total_d,
)
```
That call uses the OLD (incorrect) argument order. After creating wizard.py and the tests, update the `calc_results` call in `_build_session_response` inside main.py to match the correct signature:
```python
res = calc_results(
    Decimal(str(cal.slope)),         # calibration_slope
    Decimal(str(cal.intercept)),     # calibration_intercept
    Decimal(str(session.peak_area)), # peak_area
    actual_conc_d,                   # actual_conc_ug_ml
    actual_total_d,                  # actual_total_vol_ul
    actual_stock_d,                  # actual_stock_vol_ul — store this from Stage 3 result
)
```
Also update the Stage 3 section of `_build_session_response` to retain `actual_stock_d` from the `calc_actual_dilution` result for passing to `calc_results`.

Once all tests pass, commit:
```bash
git add backend/calculations/wizard.py backend/main.py
git commit -m "feat(01-02): implement wizard Decimal calculation engine"
```
  </action>
  <verify>
```bash
cd backend && python -m pytest tests/test_wizard_calculations.py -v
```
All tests must show PASSED. No FAILED or ERROR.

Also verify the module can be imported from parent context:
```bash
cd backend && python -c "from calculations.wizard import calc_stock_prep, calc_required_volumes, calc_actual_dilution, calc_results; print('import OK')"
```
  </verify>
  <done>
`python -m pytest tests/test_wizard_calculations.py -v` shows all tests PASSED. The complete calculation chain produces the lab-verified values: stock_conc ≈ 16595.82 µg/mL, required_stock_vol ≈ 72.31 µL. All returned values are Decimal instances. The calc_results call in main.py uses the correct argument order.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `python -m pytest backend/tests/test_wizard_calculations.py -v` — all tests PASSED
2. `python -c "from calculations.wizard import calc_stock_prep; from decimal import Decimal; r = calc_stock_prep(Decimal('50'), Decimal('5501.68'), Decimal('8505.75'), Decimal('997.1')); print(round(float(r['stock_conc_ug_ml']), 2))"` prints `16595.82`
3. Git log shows two commits: RED commit (test file, failing) then GREEN commit (implementation)
4. No float values inside wizard.py — all arithmetic operates on Decimal throughout
5. No imports from models.py, main.py, database.py, or auth.py inside wizard.py
</verification>

<success_criteria>
- backend/calculations/wizard.py exists with four functions: calc_stock_prep, calc_required_volumes, calc_actual_dilution, calc_results
- All functions accept and return Decimal — no float arithmetic inside wizard.py
- backend/tests/test_wizard_calculations.py exists with tests for all four functions
- All tests pass: `python -m pytest tests/test_wizard_calculations.py` shows 0 failures
- Lab Excel verification: calc_stock_prep(50mg declared, 5501.68 empty, 8505.75 loaded, 997.1 density) returns stock_conc_ug_ml ≈ 16595.82
- calc_results argument order matches what the test file and _build_session_response use
- Two git commits: one RED (test file only), one GREEN (implementation)
</success_criteria>

<output>
After completion, create `.planning/phases/01-wizard-db/01-02-SUMMARY.md` using the summary template.
</output>
