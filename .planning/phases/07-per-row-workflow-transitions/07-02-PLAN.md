---
phase: 07-per-row-workflow-transitions
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/components/senaite/SampleDetails.tsx
autonomous: true

must_haves:
  truths:
    - "After any analysis transition, the sample-level status badge and progress bar update to reflect the new state"
    - "After submitting an unassigned analysis, the row badge changes to to_be_verified and the progress bar does NOT change (still pending)"
    - "After verifying a to_be_verified analysis, the progress bar advances and verified count increases"
    - "The page does NOT flash a full-page loading spinner during post-transition refresh"
    - "Sample-level auto-transitions (e.g. sample_received -> to_be_verified when all analyses submitted) are visible immediately after refresh"
  artifacts:
    - path: "src/components/senaite/SampleDetails.tsx"
      provides: "refreshSample silent fetch + onTransitionComplete wiring to AnalysisTable"
      contains: "onTransitionComplete"
  key_links:
    - from: "src/components/senaite/SampleDetails.tsx"
      to: "AnalysisTable onTransitionComplete prop"
      via: "callback triggering refreshSample"
      pattern: "onTransitionComplete.*refreshSample"
    - from: "refreshSample function"
      to: "lookupSenaiteSample"
      via: "silent fetch (no setLoading(true))"
      pattern: "lookupSenaiteSample.*\\.then.*setData"
---

<objective>
Wire SampleDetails to silently refresh after any analysis transition, so the sample-level status badge, progress bar, and verified/pending counters all update without a full-page loading flash.

Purpose: Transitions change analysis-level state, but sample-level aggregates (progress bar, verified count, status badge) are computed from the full sample data. A silent re-fetch after each transition keeps everything in sync. This completes requirements REFR-01 and REFR-02.

Output: After any transition (submit, verify, retract, reject) on any analysis row, SampleDetails calls lookupSenaiteSample without triggering the loading spinner, and updates all derived state from the fresh response.
</objective>

<execution_context>
@C:\Users\forre\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\forre\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-per-row-workflow-transitions/07-RESEARCH.md
@.planning/phases/07-per-row-workflow-transitions/07-01-SUMMARY.md

@src/components/senaite/SampleDetails.tsx (full file — adding refreshSample + onTransitionComplete prop)
@src/components/senaite/AnalysisTable.tsx (Plan 01 output — has onTransitionComplete prop in interface)
@src/lib/api.ts (lookupSenaiteSample function)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Silent refreshSample function + onTransitionComplete wiring</name>
  <files>src/components/senaite/SampleDetails.tsx</files>
  <action>
**Add a `refreshSample` function** in the SampleDetails component body (near the existing `fetchSample` function, around line 430). This is a "silent" variant that does NOT set `loading = true`, avoiding the full-page loading spinner flash:

```typescript
/** Silent re-fetch: updates data without triggering full-page loading state. */
const refreshSample = (id: string) => {
  lookupSenaiteSample(id)
    .then(result => setData(result))
    .catch(e => toast.error('Refresh failed', { description: e instanceof Error ? e.message : String(e) }))
}
```

Key differences from `fetchSample`:
- Does NOT call `setLoading(true)` — page content stays visible during the fetch
- Does NOT call `setError(null)` — keeps current error state if any
- On error, shows a toast instead of replacing the page with an error state
- On success, replaces `data` entirely — this means verifiedCount, pendingCount, progressPct, sample-level StatusBadge, and the analyses array all update from the fresh response

**Wire `onTransitionComplete` prop** to the AnalysisTable render (around line 1050). Update the existing `<AnalysisTable>` call to include the new prop:

```tsx
<AnalysisTable
  analyses={analyses}
  analyteNameMap={analyteNameMap}
  onResultSaved={(uid, newResult, newReviewState) => {
    setData(prev => {
      if (!prev) return prev
      return {
        ...prev,
        analyses: prev.analyses.map(a =>
          a.uid === uid
            ? { ...a, result: newResult, review_state: newReviewState ?? a.review_state }
            : a
        ),
      }
    })
  }}
  onTransitionComplete={() => refreshSample(data.sample_id)}
/>
```

IMPORTANT: `data` is guaranteed non-null at this point in the render tree (we return early for loading/error states above). The `data.sample_id` reference is safe.

This completes the callback chain: AnalysisTable -> useAnalysisTransition.executeTransition -> onTransitionComplete -> refreshSample -> lookupSenaiteSample -> setData -> re-render with fresh analyses, counters, badges, progress bar.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npm run build` succeeds
    - SampleDetails.tsx contains `refreshSample` function that calls `lookupSenaiteSample` without `setLoading(true)`
    - AnalysisTable render includes `onTransitionComplete={() => refreshSample(data.sample_id)}`
    - The `refreshSample` function does NOT appear inside the `fetchSample` function (they are separate)
  </verify>
  <done>
    - refreshSample function exists in SampleDetails, performs silent re-fetch (no loading spinner flash)
    - AnalysisTable receives onTransitionComplete prop wired to refreshSample
    - After any transition, the full sample data re-fetches and all derived state (counters, badges, progress bar) updates
    - Requirements REFR-01 (re-fetch parent sample after transition) and REFR-02 (sample-level auto-transitions visible) are complete
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — zero type errors
2. `npm run build` — production build succeeds
3. In SampleDetails.tsx: `refreshSample` function exists and does NOT contain `setLoading`
4. In SampleDetails.tsx: `onTransitionComplete` prop is passed to `<AnalysisTable>`
5. The callback chain is complete: AnalysisTable.onTransitionComplete -> refreshSample -> lookupSenaiteSample -> setData
</verification>

<success_criteria>
- Requirements REFR-01 (re-fetch parent sample after any analysis transition) and REFR-02 (sample-level auto-transitions visible immediately) are implemented
- The page does not flash a full-page loading spinner during post-transition refresh
- All code compiles and builds without errors
- Combined with Plan 01, ALL Phase 07 requirements (WKFL-01 through WKFL-07, REFR-01, REFR-02) are complete
</success_criteria>

<output>
After completion, create `.planning/phases/07-per-row-workflow-transitions/07-02-SUMMARY.md`
</output>
