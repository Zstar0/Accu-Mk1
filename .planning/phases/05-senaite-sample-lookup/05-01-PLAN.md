---
phase: 05-senaite-sample-lookup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/main.py
  - backend/.env.example
  - src/lib/api.ts
autonomous: true

must_haves:
  truths:
    - "GET /wizard/senaite/status returns {enabled: true} when SENAITE_URL is set, {enabled: false} when absent"
    - "GET /wizard/senaite/lookup?id=P-0112 returns sample_id, declared_weight_mg, and analytes array with stripped names and matched peptide IDs"
    - "GET /wizard/senaite/lookup?id=NONEXISTENT returns HTTP 404 with 'Sample NONEXISTENT not found in SENAITE'"
    - "GET /wizard/senaite/lookup returns HTTP 503 when SENAITE is unreachable or times out"
    - "Frontend can call getSenaiteStatus() and lookupSenaiteSample() via typed api.ts functions"
  artifacts:
    - path: "backend/main.py"
      provides: "SENAITE env vars, _fetch_senaite_sample, _strip_method_suffix, _fuzzy_match_peptide, /wizard/senaite/status, /wizard/senaite/lookup endpoints"
      contains: "SENAITE_URL"
    - path: "backend/.env.example"
      provides: "SENAITE configuration section"
      contains: "SENAITE_URL"
    - path: "src/lib/api.ts"
      provides: "SenaiteLookupResult, SenaiteAnalyte, SenaiteStatusResponse types; getSenaiteStatus, lookupSenaiteSample functions"
      exports: ["getSenaiteStatus", "lookupSenaiteSample", "SenaiteLookupResult", "SenaiteAnalyte", "SenaiteStatusResponse"]
  key_links:
    - from: "src/lib/api.ts"
      to: "/wizard/senaite/lookup"
      via: "fetch call in lookupSenaiteSample"
      pattern: "wizard/senaite/lookup"
    - from: "backend/main.py"
      to: "SENAITE REST API"
      via: "httpx.AsyncClient with BasicAuth"
      pattern: "httpx\\.AsyncClient.*auth"
---

<objective>
Add SENAITE REST API integration to the backend and typed frontend API functions.

Purpose: Enable the wizard to look up sample details (ID, peptide name, declared weight) from the SENAITE LIMS by sample ID, with proper error differentiation (not found vs. unavailable).

Output: Two new backend endpoints (`/wizard/senaite/status` and `/wizard/senaite/lookup`), SENAITE env var configuration, and typed frontend API client functions ready for the Step 1 UI to consume.
</objective>

<execution_context>
@C:\Users\forre\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\forre\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-senaite-sample-lookup/05-CONTEXT.md
@.planning/phases/05-senaite-sample-lookup/05-RESEARCH.md
@backend/main.py
@backend/.env.example
@src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: SENAITE backend endpoints and env config</name>
  <files>backend/main.py, backend/.env.example</files>
  <action>
**In `backend/main.py`:**

1. Add SENAITE env var constants near the Integration Service section (around line 3983):
   ```python
   # -- SENAITE Integration -----------------------------------------------
   SENAITE_URL = os.environ.get("SENAITE_URL")          # None = disabled
   SENAITE_USER = os.environ.get("SENAITE_USER", "")
   SENAITE_PASSWORD = os.environ.get("SENAITE_PASSWORD", "")
   SENAITE_TIMEOUT = httpx.Timeout(connect=5.0, read=10.0)
   ```

2. Add Pydantic response models (near other BaseModel definitions):
   ```python
   class SenaiteAnalyte(BaseModel):
       raw_name: str
       matched_peptide_id: Optional[int] = None
       matched_peptide_name: Optional[str] = None

   class SenaiteLookupResult(BaseModel):
       sample_id: str
       declared_weight_mg: Optional[float] = None
       analytes: list[SenaiteAnalyte]

   class SenaiteStatusResponse(BaseModel):
       enabled: bool
   ```

3. Add helper functions:
   - `_strip_method_suffix(name: str) -> str` — uses `re.sub(r'\s*-\s*[^-]+\([^)]+\)\s*$', '', name).strip()` to strip ` - Method (Type)` suffixes from analyte names like `"BPC-157 - Identity (HPLC)"`.
   - `_fuzzy_match_peptide(stripped_name: str, peptides: list) -> Optional[tuple[int, str]]` — case-insensitive substring match: `stripped_name.lower() in p.name.lower()`. Returns `(peptide.id, peptide.name)` or None. Per Claude's discretion: use simple `contains` match (not Levenshtein).
   - `async def _fetch_senaite_sample(sample_id: str) -> dict` — calls `GET {SENAITE_URL}/senaite/@@API/senaite/v1/AnalysisRequest?id={sample_id}&complete=yes` using `httpx.AsyncClient(timeout=SENAITE_TIMEOUT, auth=httpx.BasicAuth(SENAITE_USER, SENAITE_PASSWORD))`. Calls `resp.raise_for_status()` and returns `resp.json()`.

4. Add `GET /wizard/senaite/status` endpoint:
   - Returns `SenaiteStatusResponse(enabled=SENAITE_URL is not None)`
   - Protected by `get_current_user` dependency (same as other wizard endpoints)

5. Add `GET /wizard/senaite/lookup` endpoint:
   - Query param: `id: str`
   - Protected by `get_current_user` dependency
   - If `SENAITE_URL` is None: raise `HTTPException(503, "SENAITE not configured")`
   - Call `_fetch_senaite_sample(id)`, check `count == 0` -> raise `HTTPException(404, f"Sample {id} not found in SENAITE")`
   - Parse `items[0]`:
     - `sample_id` = `item["id"]`
     - `declared_weight_mg` = parse `item.get("DeclaredTotalQuantity")` as float if non-null/non-empty, else None
     - Iterate `Analyte1Peptide` through `Analyte4Peptide`: for each non-null value, strip method suffix, fuzzy match against peptides from DB (`db.query(Peptide).all()`), build `SenaiteAnalyte` with `raw_name`, `matched_peptide_id`, `matched_peptide_name`
   - Return `SenaiteLookupResult`
   - Error handling (per user decision — differentiate errors):
     - `HTTPException` re-raised as-is (covers 404 not-found)
     - `httpx.TimeoutException` -> `HTTPException(503, "SENAITE is currently unavailable -- use manual entry")`
     - `httpx.HTTPStatusError` -> `HTTPException(503, "SENAITE is currently unavailable -- use manual entry")`
     - Generic `Exception` -> `HTTPException(503, "SENAITE is currently unavailable -- use manual entry")`
   - NOTE: Use em-dash character in the user-facing messages (matching the exact strings from CONTEXT.md decisions)

**In `backend/.env.example`:**

6. Append a SENAITE section after the Scale section:
   ```
   # ============================================================
   # SENAITE LIMS Integration
   # ============================================================
   # Set SENAITE_URL to enable sample lookup in the wizard.
   # Leave commented out to disable the SENAITE Lookup tab entirely.
   # Docker network: http://senaite:8080
   # SENAITE_URL=http://senaite:8080
   # SENAITE_USER=admin
   # SENAITE_PASSWORD=your_senaite_password
   ```
  </action>
  <verify>
    - `python -c "import main"` from backend dir does not error (syntax check)
    - Grep `backend/main.py` for `SENAITE_URL`, `_fetch_senaite_sample`, `_strip_method_suffix`, `_fuzzy_match_peptide`, `/wizard/senaite/status`, `/wizard/senaite/lookup` — all present
    - Grep `backend/.env.example` for `SENAITE_URL` — present
  </verify>
  <done>
    - Two new endpoints exist: `/wizard/senaite/status` and `/wizard/senaite/lookup`
    - Status endpoint returns `{enabled: bool}` based on SENAITE_URL env var
    - Lookup endpoint calls SENAITE REST API via httpx with Basic auth
    - Lookup endpoint differentiates: 404 for not-found, 503 for unreachable/timeout
    - Analyte names are stripped of method suffixes and fuzzy-matched against local peptides
    - .env.example has SENAITE configuration section
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend SENAITE API types and functions</name>
  <files>src/lib/api.ts</files>
  <action>
Add the following to `src/lib/api.ts` after the existing wizard session functions (around line 1885):

1. Add TypeScript interfaces:
   ```typescript
   // --- SENAITE Lookup API ---

   export interface SenaiteAnalyte {
     raw_name: string
     matched_peptide_id: number | null
     matched_peptide_name: string | null
   }

   export interface SenaiteLookupResult {
     sample_id: string
     declared_weight_mg: number | null
     analytes: SenaiteAnalyte[]
   }

   export interface SenaiteStatusResponse {
     enabled: boolean
   }
   ```

2. Add `getSenaiteStatus()` function:
   ```typescript
   export async function getSenaiteStatus(): Promise<SenaiteStatusResponse> {
     const response = await fetch(`${API_BASE_URL()}/wizard/senaite/status`, {
       headers: getBearerHeaders(),
     })
     if (!response.ok) throw new Error(`SENAITE status check failed: ${response.status}`)
     return response.json()
   }
   ```

3. Add `lookupSenaiteSample()` function:
   ```typescript
   export async function lookupSenaiteSample(
     sampleId: string
   ): Promise<SenaiteLookupResult> {
     const response = await fetch(
       `${API_BASE_URL()}/wizard/senaite/lookup?id=${encodeURIComponent(sampleId)}`,
       { headers: getBearerHeaders() }
     )
     if (!response.ok) {
       const err = await response.json().catch(() => null)
       throw new Error(err?.detail || `SENAITE lookup failed: ${response.status}`)
     }
     return response.json()
   }
   ```

The `lookupSenaiteSample` function throws with the backend's `detail` message, which is already user-readable ("Sample X not found in SENAITE" for 404, "SENAITE is currently unavailable..." for 503). The Step1 UI will display the error message directly.
  </action>
  <verify>
    - `npx tsc --noEmit` passes (no TypeScript errors in api.ts)
    - Grep `src/lib/api.ts` for `SenaiteLookupResult`, `getSenaiteStatus`, `lookupSenaiteSample` — all present
  </verify>
  <done>
    - `SenaiteAnalyte`, `SenaiteLookupResult`, `SenaiteStatusResponse` types exported from api.ts
    - `getSenaiteStatus()` calls GET /wizard/senaite/status
    - `lookupSenaiteSample(sampleId)` calls GET /wizard/senaite/lookup with URL-encoded ID
    - Error messages from backend detail field are propagated to caller
  </done>
</task>

</tasks>

<verification>
- Backend syntax check passes (no import errors)
- TypeScript compilation passes (no type errors in api.ts)
- All SENAITE-related functions and endpoints discoverable via grep
- .env.example includes SENAITE section
</verification>

<success_criteria>
- Backend exposes /wizard/senaite/status and /wizard/senaite/lookup endpoints
- Frontend api.ts exports typed functions to call both endpoints
- Error differentiation: 404 for not-found, 503 for unavailable
- Analyte name suffix stripping and fuzzy peptide matching implemented
- SENAITE env vars documented in .env.example
</success_criteria>

<output>
After completion, create `.planning/phases/05-senaite-sample-lookup/05-01-SUMMARY.md`
</output>
