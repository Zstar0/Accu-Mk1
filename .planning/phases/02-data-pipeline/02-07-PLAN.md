---
phase: 02-data-pipeline
plan: 07
type: execute
wave: 1
depends_on: []
files_modified: [backend/main.py, backend/file_watcher.py, src/lib/api.ts, src/components/layout/MainWindowContent.tsx]
autonomous: true
gap_closure: true
must_haves:
  truths:
    - "System detects new CSV files in watched directory"
  artifacts:
    - path: "backend/file_watcher.py"
      provides: "FileWatcher class"
      contains: "class FileWatcher"
    - path: "backend/main.py"
      provides: "File watcher API endpoints"
      contains: "/watcher/"
  key_links:
    - from: "FileWatcher"
      to: "/watcher/status"
      via: "API endpoints"
---

<objective>
Implement file watcher that monitors configured directory for new HPLC export files.

Purpose: Close gap from verification - only manual file selection exists.
Output: Backend file watcher that detects new .txt files in report_directory.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-pipeline/02-02-SUMMARY.md

@backend/main.py
@src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FileWatcher module</name>
  <files>backend/file_watcher.py</files>
  <action>
    Create file_watcher.py with FileWatcher class:

    ```python
    import os
    import threading
    import time
    from pathlib import Path
    from typing import Callable, Optional
    from watchdog.observers import Observer
    from watchdog.events import FileSystemEventHandler, FileCreatedEvent

    class HPLCFileHandler(FileSystemEventHandler):
        """Handle new file events in watched directory."""

        def __init__(self, callback: Callable[[str], None], extensions: list[str]):
            self.callback = callback
            self.extensions = extensions

        def on_created(self, event: FileCreatedEvent):
            if not event.is_directory:
                path = Path(event.src_path)
                if path.suffix.lower() in self.extensions:
                    self.callback(str(path))

    class FileWatcher:
        """
        Watch a directory for new HPLC export files.

        Uses watchdog library for cross-platform file system monitoring.
        """

        def __init__(self):
            self.observer: Optional[Observer] = None
            self.watch_path: Optional[str] = None
            self.detected_files: list[str] = []
            self.is_running = False
            self._lock = threading.Lock()

        def start(self, directory: str, extensions: list[str] = [".txt"]):
            """Start watching directory for new files."""
            if self.is_running:
                self.stop()

            self.watch_path = directory
            self.detected_files = []

            handler = HPLCFileHandler(self._on_file_detected, extensions)
            self.observer = Observer()
            self.observer.schedule(handler, directory, recursive=False)
            self.observer.start()
            self.is_running = True

        def stop(self):
            """Stop watching directory."""
            if self.observer:
                self.observer.stop()
                self.observer.join()
                self.observer = None
            self.is_running = False

        def _on_file_detected(self, file_path: str):
            """Callback when new file detected."""
            with self._lock:
                if file_path not in self.detected_files:
                    self.detected_files.append(file_path)

        def get_detected_files(self) -> list[str]:
            """Get list of detected files and clear the list."""
            with self._lock:
                files = self.detected_files.copy()
                self.detected_files = []
                return files

        def status(self) -> dict:
            """Get watcher status."""
            return {
                "is_running": self.is_running,
                "watch_path": self.watch_path,
                "pending_files": len(self.detected_files),
            }
    ```

    Note: Requires watchdog package - add to requirements.txt if exists, or document as dependency.
  </action>
  <verify>python -c "from file_watcher import FileWatcher; print(FileWatcher)"</verify>
  <done>FileWatcher class exists with start/stop/status methods</done>
</task>

<task type="auto">
  <name>Task 2: Add watcher API endpoints</name>
  <files>backend/main.py</files>
  <action>
    1. Import FileWatcher at top of file
    2. Create global watcher instance: file_watcher = FileWatcher()
    3. Add endpoints:

    ```python
    @app.get("/watcher/status")
    async def get_watcher_status():
        """Get file watcher status."""
        return file_watcher.status()

    @app.post("/watcher/start")
    async def start_watcher(db: Session = Depends(get_db)):
        """Start file watcher using report_directory from settings."""
        # Get report_directory from settings
        setting = db.query(Setting).filter(Setting.key == "report_directory").first()
        if not setting or not setting.value:
            raise HTTPException(400, "report_directory not configured")

        if not os.path.isdir(setting.value):
            raise HTTPException(400, f"Directory does not exist: {setting.value}")

        file_watcher.start(setting.value)
        return {"status": "started", "watching": setting.value}

    @app.post("/watcher/stop")
    async def stop_watcher():
        """Stop file watcher."""
        file_watcher.stop()
        return {"status": "stopped"}

    @app.get("/watcher/files")
    async def get_detected_files():
        """Get and clear list of detected files."""
        files = file_watcher.get_detected_files()
        return {"files": files, "count": len(files)}
    ```
  </action>
  <verify>curl http://127.0.0.1:8009/watcher/status</verify>
  <done>Watcher API endpoints respond correctly</done>
</task>

<task type="auto">
  <name>Task 3: Add watcher TypeScript client</name>
  <files>src/lib/api.ts</files>
  <action>
    Add watcher API functions:

    ```typescript
    // File watcher types
    interface WatcherStatus {
      is_running: boolean
      watch_path: string | null
      pending_files: number
    }

    interface DetectedFiles {
      files: string[]
      count: number
    }

    // File watcher functions
    export async function getWatcherStatus(): Promise<WatcherStatus> {
      const response = await fetch(`${API_BASE_URL}/watcher/status`)
      if (!response.ok) throw new Error('Failed to get watcher status')
      return response.json()
    }

    export async function startWatcher(): Promise<{ status: string; watching: string }> {
      const response = await fetch(`${API_BASE_URL}/watcher/start`, { method: 'POST' })
      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.detail || 'Failed to start watcher')
      }
      return response.json()
    }

    export async function stopWatcher(): Promise<{ status: string }> {
      const response = await fetch(`${API_BASE_URL}/watcher/stop`, { method: 'POST' })
      if (!response.ok) throw new Error('Failed to stop watcher')
      return response.json()
    }

    export async function getDetectedFiles(): Promise<DetectedFiles> {
      const response = await fetch(`${API_BASE_URL}/watcher/files`)
      if (!response.ok) throw new Error('Failed to get detected files')
      return response.json()
    }
    ```
  </action>
  <verify>grep -l "getWatcherStatus" src/lib/api.ts</verify>
  <done>Watcher client functions exist in api.ts</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] FileWatcher class exists in file_watcher.py
- [ ] Watcher endpoints respond: /watcher/status, /watcher/start, /watcher/stop, /watcher/files
- [ ] TypeScript client has watcher functions
- [ ] Manual test: Configure report_directory, start watcher, drop file, see in /watcher/files
</verification>

<success_criteria>
- FileWatcher monitors directory for new .txt files
- API endpoints control watcher start/stop and retrieve detected files
- TypeScript client can interact with watcher
- Watcher reads report_directory from settings
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-pipeline/02-07-SUMMARY.md`
</output>
