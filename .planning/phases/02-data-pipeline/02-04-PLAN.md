---
phase: 02-data-pipeline
plan: 02-04
title: Calculation Engine
wave: 2
status: pending
requirements: [CALC-01, CALC-02, CALC-03, CALC-04]
depends_on: [02-02]
created: 2026-01-16
---

## Goal

Implement the core calculation engine that processes imported HPLC data. Support accumulation calculations, response factor application, and dilution factor calculations.

## Context

After files are imported (02-02), the calculation engine processes the parsed data. Calculations are defined by formulas that can be configured. Results are stored per-sample and can be reviewed in Phase 3.

## Tasks

### Task 1: Calculation Framework

**Files to create:**
- `backend/calculations/__init__.py` - Calculations module init
- `backend/calculations/engine.py` - Core calculation engine
- `backend/calculations/formulas.py` - Individual calculation formulas

**Implementation:**

1. Create calculation engine:
```python
class CalculationEngine:
    def __init__(self, settings: dict):
        self.settings = settings

    def calculate(self, sample_data: dict, calculation_type: str) -> CalculationResult:
        """Run specified calculation on sample data."""
        formula = self.get_formula(calculation_type)
        return formula.execute(sample_data, self.settings)
```

2. Define formula base class:
```python
class Formula(ABC):
    @abstractmethod
    def execute(self, data: dict, settings: dict) -> CalculationResult

    @abstractmethod
    def validate(self, data: dict) -> list[str]  # Return validation errors
```

3. CalculationResult dataclass:
```python
@dataclass
class CalculationResult:
    calculation_type: str
    input_summary: dict
    output_values: dict
    warnings: list[str]
    success: bool
```

### Task 2: Core Formulas Implementation

**Files to modify:**
- `backend/calculations/formulas.py` - Add specific formulas

**Implementation:**

1. AccumulationFormula:
   - Sums peak areas across specified retention time windows
   - Input: parsed rows, RT window settings
   - Output: total_area, peak_count, window_summary

2. ResponseFactorFormula:
   - Applies response factor to convert areas to concentrations
   - Input: area values, response factor from settings
   - Output: calculated_concentration, applied_factor

3. DilutionFactorFormula:
   - Adjusts concentrations by dilution factor
   - Input: concentration, dilution factor
   - Output: final_concentration, dilution_applied

4. Each formula implements validate() to check required inputs

### Task 3: Calculation API Endpoints

**Files to modify:**
- `backend/main.py` - Add calculation endpoints

**Implementation:**

1. Add endpoints:
   - `POST /calculate/{sample_id}` - Run all calculations for a sample
   - `GET /calculations/types` - List available calculation types
   - `POST /calculate/preview` - Run calculation without saving (for testing)

2. Calculate endpoint:
```python
@app.post("/calculate/{sample_id}")
async def calculate_sample(sample_id: int, db: Session = Depends(get_db)):
    # Load sample and its input_data
    # Load settings for calculation parameters
    # Run all applicable calculations
    # Store results in Result table
    # Return calculation summary
```

3. Auto-calculate on import option:
   - Add setting `auto_calculate` (default: false)
   - If enabled, trigger calculations after successful import

### Task 4: Calculation TypeScript Client

**Files to modify:**
- `src/lib/api.ts` - Add calculation API functions

**Implementation:**

1. Add typed interfaces:
```typescript
interface CalculationResult {
  calculation_type: string
  input_summary: Record<string, unknown>
  output_values: Record<string, number | string>
  warnings: string[]
  success: boolean
}

interface CalculationSummary {
  sample_id: number
  results: CalculationResult[]
  total_calculations: number
  successful: number
  failed: number
}
```

2. Add API functions:
   - `calculateSample(sampleId: number): Promise<CalculationSummary>`
   - `getCalculationTypes(): Promise<string[]>`
   - `previewCalculation(data: object, type: string): Promise<CalculationResult>`

## Verification

```bash
# Import a test file first (via 02-02)
# Then run calculations

# Get sample ID from import
SAMPLE_ID=1

# Run calculations
curl -X POST "http://127.0.0.1:8009/calculate/$SAMPLE_ID"

# Verify results stored
curl "http://127.0.0.1:8009/samples/$SAMPLE_ID/results"

# List calculation types
curl http://127.0.0.1:8009/calculations/types
```

## Must-Haves

- [ ] Calculation engine processes sample data
- [ ] At least one formula (accumulation) implemented
- [ ] Results stored in Result table linked to Sample
- [ ] Validation errors reported clearly
- [ ] API endpoint triggers calculation for a sample

## Notes

- Formulas are configurable via settings (response factors, RT windows)
- Keep formulas simple and testable
- Audit log entries for all calculations
- Phase 3 will add UI for viewing/editing results
- Consider adding unit tests for formula accuracy
