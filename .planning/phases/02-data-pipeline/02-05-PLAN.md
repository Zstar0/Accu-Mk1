---
phase: 02-data-pipeline
plan: 05
type: execute
wave: 1
depends_on: []
files_modified: [backend/calculations/formulas.py, backend/calculations/engine.py, backend/main.py]
autonomous: true
gap_closure: true
must_haves:
  truths:
    - "Purity % calculates correctly using linear equation"
  artifacts:
    - path: "backend/calculations/formulas.py"
      provides: "PurityFormula class"
      contains: "class PurityFormula"
  key_links:
    - from: "PurityFormula"
      to: "CalculationEngine"
      via: "formula_registry"
---

<objective>
Implement purity percentage calculation using linear equation (serial dilution method).

Purpose: Close gap from verification - no purity calculation exists yet.
Output: PurityFormula class that calculates purity % from peak areas using calibration curve.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-pipeline/02-04-SUMMARY.md

@backend/calculations/formulas.py
@backend/calculations/engine.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PurityFormula class</name>
  <files>backend/calculations/formulas.py</files>
  <action>
    Add PurityFormula class after DilutionFactorFormula:

    The purity calculation uses a linear equation from calibration:
    purity_% = (peak_area - intercept) / slope

    Settings required:
    - calibration_slope: Slope from calibration curve
    - calibration_intercept: Y-intercept from calibration curve

    Inputs:
    - rows with peak_area values (or total_area already calculated)

    Outputs:
    - purity_percent: Calculated purity percentage
    - total_area: The area used in calculation
    - calibration_used: {slope, intercept}

    Validation:
    - slope cannot be zero
    - peak_area or total_area must exist
    - warn if purity outside 0-100% range (but still return value)
  </action>
  <verify>python -c "from formulas import PurityFormula; print(PurityFormula)"</verify>
  <done>PurityFormula class exists with validate() and execute() methods</done>
</task>

<task type="auto">
  <name>Task 2: Register PurityFormula in engine</name>
  <files>backend/calculations/engine.py</files>
  <action>
    1. Import PurityFormula from formulas
    2. Add to FORMULA_REGISTRY: "purity": PurityFormula
    3. Add "purity" to default enabled_formulas in calculate_all if calibration settings exist
  </action>
  <verify>python -c "from engine import FORMULA_REGISTRY; print('purity' in FORMULA_REGISTRY)"</verify>
  <done>purity formula registered and callable via engine</done>
</task>

<task type="auto">
  <name>Task 3: Add calibration settings defaults</name>
  <files>backend/main.py</files>
  <action>
    In seed_default_settings(), add default calibration settings:
    - calibration_slope: "1.0" (placeholder, user must configure)
    - calibration_intercept: "0.0" (placeholder)

    This ensures the settings exist in the database for the purity formula to reference.
  </action>
  <verify>curl http://127.0.0.1:8009/settings | grep calibration</verify>
  <done>Calibration settings seeded with defaults</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] PurityFormula class exists in formulas.py
- [ ] Formula registered in FORMULA_REGISTRY
- [ ] calibration_slope and calibration_intercept in default settings
- [ ] Manual test: POST /calculate/{sample_id} with purity settings returns purity_percent
</verification>

<success_criteria>
- PurityFormula calculates purity % = (area - intercept) / slope
- Validates calibration settings are present and non-zero slope
- Registered in engine and callable
- Default settings seeded
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-pipeline/02-05-SUMMARY.md`
</output>
