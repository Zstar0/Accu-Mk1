---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified: [backend/, src-tauri/tauri.conf.json, src-tauri/src/main.rs, src/lib/api.ts]
autonomous: true
must_haves:
  truths:
    - "FastAPI backend starts and responds to health check"
    - "SQLite database initializes with schema"
    - "Audit log table exists and can receive entries"
    - "Frontend can communicate with backend"
  artifacts:
    - path: "backend/main.py"
      provides: "FastAPI application entry point"
      contains: "FastAPI"
    - path: "backend/database.py"
      provides: "SQLite database setup"
      contains: "sqlite"
    - path: "backend/models.py"
      provides: "Database models including audit_logs"
      contains: "audit_logs"
    - path: "src-tauri/tauri.conf.json"
      provides: "Sidecar configuration"
      contains: "externalBin"
    - path: "src/lib/api.ts"
      provides: "Frontend API client"
      contains: "fetch"
  key_links:
    - from: "src/lib/api.ts"
      to: "localhost:8008"
      via: "fetch requests to FastAPI"
    - from: "backend/main.py"
      to: "backend/database.py"
      via: "SQLAlchemy connection"
    - from: "src-tauri/src/main.rs"
      to: "backend sidecar"
      via: "shell().sidecar()"
---

<objective>
Create FastAPI backend with SQLite database and audit logging, wire it as Tauri sidecar.

Purpose: Establish the backend that owns all scientific logic, calculations, and data persistence.
Output: Working FastAPI server that runs as sidecar in Tauri and standalone for browser mode.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

FastAPI sidecar pattern:
- Backend compiled with PyInstaller into single executable
- Tauri spawns via shell().sidecar() on app start
- Runs on localhost:8008
- Frontend communicates via HTTP fetch

Database requirements:
- SQLite for local-first storage
- Audit log table for all operations (INFRA-04)
- Schema must support jobs, results, and logs (INFRA-03)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FastAPI backend structure</name>
  <files>backend/main.py, backend/database.py, backend/models.py, backend/requirements.txt</files>
  <action>
    Create the Python backend directory structure with FastAPI, SQLAlchemy, and SQLite.

    Create backend/requirements.txt:
    ```
    fastapi==0.115.0
    uvicorn[standard]==0.32.0
    sqlalchemy==2.0.35
    pydantic==2.9.0
    ```

    Create backend/database.py:
    - SQLite connection using SQLAlchemy
    - Database file at ./data/accu-mk1.db (relative to working dir)
    - Create data directory if not exists
    - Session maker for dependency injection

    Create backend/models.py:
    - AuditLog model: id, timestamp, operation, entity_type, entity_id, details (JSON), created_at
    - Job model: id, status, source_directory, created_at, completed_at
    - Sample model: id, job_id, filename, status, created_at
    - Result model: id, sample_id, calculation_type, input_data (JSON), output_data (JSON), created_at

    Create backend/main.py:
    - FastAPI app with CORS enabled (allow localhost origins)
    - Health check endpoint: GET /health returns {"status": "ok", "version": "0.1.0"}
    - Database initialization on startup
    - Audit log endpoint: POST /audit to create audit entry
    - GET /audit to list recent audit entries

    IMPORTANT: Use SQLAlchemy 2.0 style (no legacy Query API). Use async where appropriate.
  </action>
  <verify>
    - All files created in backend/ directory
    - requirements.txt has correct dependencies
    - Models define all required tables
    - main.py has health and audit endpoints
  </verify>
  <done>FastAPI backend structure created with SQLite and audit logging</done>
</task>

<task type="auto">
  <name>Task 2: Test backend standalone</name>
  <files>backend/</files>
  <action>
    Set up Python environment and test the backend runs correctly.

    Steps:
    1. Create Python virtual environment: python -m venv backend/.venv
    2. Activate and install: pip install -r backend/requirements.txt
    3. Run: uvicorn backend.main:app --host 127.0.0.1 --port 8008
    4. Test health endpoint: curl http://127.0.0.1:8008/health
    5. Test audit POST: curl -X POST http://127.0.0.1:8008/audit -H "Content-Type: application/json" -d '{"operation": "test", "entity_type": "system", "details": {"msg": "init"}}'
    6. Test audit GET: curl http://127.0.0.1:8008/audit
    7. Stop the server

    Verify SQLite database file created at data/accu-mk1.db
  </action>
  <verify>
    - Health endpoint returns 200 with status ok
    - Audit POST creates entry
    - Audit GET returns list with created entry
    - SQLite file exists at data/accu-mk1.db
  </verify>
  <done>Backend runs standalone, all endpoints work, database persists</done>
</task>

<task type="auto">
  <name>Task 3: Create frontend API client</name>
  <files>src/lib/api.ts, src/lib/config.ts</files>
  <action>
    Create TypeScript API client for frontend to communicate with backend.

    Create src/lib/config.ts:
    - Export API_BASE_URL constant
    - Default to "http://127.0.0.1:8008" for both browser and Tauri modes
    - (In future, could detect Tauri and use different port)

    Create src/lib/api.ts:
    - healthCheck(): Promise<{status: string, version: string}>
    - createAuditLog(operation: string, entityType: string, entityId?: string, details?: object): Promise<AuditLog>
    - getAuditLogs(limit?: number): Promise<AuditLog[]>
    - Type definitions for AuditLog

    Use fetch API, handle errors gracefully, log to console on failure.
  </action>
  <verify>
    - src/lib/api.ts exports health and audit functions
    - src/lib/config.ts exports API_BASE_URL
    - TypeScript compiles without errors
  </verify>
  <done>Frontend API client created with typed functions</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] backend/ directory with all Python files
- [ ] Backend runs with uvicorn and responds to health check
- [ ] Audit log endpoints work (POST creates, GET retrieves)
- [ ] SQLite database file created
- [ ] Frontend API client created and compiles
- [ ] npm run dev still works (no breaking changes to frontend)
</verification>

<success_criteria>
- All tasks completed
- FastAPI backend runs on localhost:8008
- SQLite database persists data
- Audit logging works end-to-end
- Frontend can call backend (test in browser console)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
