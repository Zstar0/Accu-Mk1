---
phase: 02-scale-bridge
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/scale_bridge.py
  - backend/main.py
  - backend/test_scale.py
  - backend/.env.example
autonomous: true

must_haves:
  truths:
    - "GET /scale/status returns {status: 'disabled'} when SCALE_HOST env var is absent"
    - "GET /scale/status returns {status: 'connected'} when SCALE_HOST is set and balance is reachable"
    - "GET /scale/status returns {status: 'disconnected'} when SCALE_HOST is set but balance is unreachable"
    - "App starts normally with no SCALE_HOST — no crash, no startup error"
    - "test_scale.py can connect to a balance, send SI, and print a parsed weight reading with stability flag — standalone, no FastAPI"
    - "scale_host and scale_port appear in DEFAULT_SETTINGS and are seeded into the settings table"
    - "SCALE_HOST and SCALE_PORT are documented in .env.example"
  artifacts:
    - path: "backend/scale_bridge.py"
      provides: "ScaleBridge singleton class with MT-SICS TCP client"
      contains: "class ScaleBridge"
    - path: "backend/scale_bridge.py"
      provides: "MT-SICS response parser"
      contains: "_parse_sics_response"
    - path: "backend/test_scale.py"
      provides: "Standalone scale test script"
      contains: "asyncio.run"
    - path: "backend/main.py"
      provides: "Scale bridge lifespan integration and /scale/status endpoint"
      contains: "scale_bridge"
  key_links:
    - from: "backend/main.py lifespan()"
      to: "backend/scale_bridge.py ScaleBridge"
      via: "import and app.state.scale_bridge assignment"
      pattern: "app\\.state\\.scale_bridge"
    - from: "backend/main.py get_scale_status()"
      to: "backend/scale_bridge.py ScaleBridge.connected"
      via: "request.app.state.scale_bridge"
      pattern: "request\\.app\\.state\\.scale_bridge"
    - from: "backend/main.py lifespan()"
      to: "os.environ SCALE_HOST"
      via: "os.environ.get conditionally creates bridge or sets None"
      pattern: 'os\\.environ\\.get\\("SCALE_HOST"\\)'
---

<objective>
Create the ScaleBridge singleton TCP client for the Mettler Toledo XSR105DU balance using MT-SICS protocol, integrate it into the FastAPI lifespan, and expose a `/scale/status` endpoint. The bridge degrades gracefully to disabled mode when SCALE_HOST is not configured.

Purpose: Phase 2 establishes the hardware communication layer that Phase 3 (SSE streaming) and Phase 4 (wizard UI) build on. Without a working ScaleBridge, weight capture remains manual-only.

Output: `backend/scale_bridge.py` (ScaleBridge class + parser), extended `backend/main.py` (lifespan + endpoint + settings), `backend/test_scale.py` (standalone verification script), updated `.env.example`.
</objective>

<execution_context>
@C:\Users\forre\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\forre\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-scale-bridge/02-RESEARCH.md
@backend/main.py
@backend/file_watcher.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScaleBridge class and MT-SICS parser</name>
  <files>backend/scale_bridge.py</files>
  <action>
Create `backend/scale_bridge.py` with:

1. **`_parse_sics_response(line: str) -> dict` function** — Parse MT-SICS ASCII response line.
   - Input: stripped response string like `"SI S      8505.75 g"`
   - Returns: `{"stable": bool, "value": float, "unit": str, "raw": str}`
   - Raises `ValueError` for error responses (`ES`, `ET`, `EL`) and balance error statuses (`I`, `+`, `-`, `E`, `L`)
   - Raises `ValueError` for malformed/incomplete responses (< 4 parts after split)
   - Only accepts `S` (stable) and `D` (dynamic) as valid status flags

2. **`ScaleBridge` class** — Singleton asyncio TCP client.
   - `__init__(self, host: str, port: int)` — stores host, port, initializes `_reader`, `_writer` as None, `_connected = False`, `_reconnect_task = None`, `_lock = asyncio.Lock()`
   - `connected` property — returns `self._connected`
   - `async connect(self) -> bool` — uses `asyncio.wait_for(asyncio.open_connection(host, port), timeout=5.0)`. Sets `_connected = True` on success, `False` on any exception. Catches `ConnectionRefusedError, TimeoutError, OSError`. Logs via `logging.getLogger(__name__)`.
   - `async disconnect(self)` — sets `_connected = False`, closes writer if exists (`writer.close()` + `await writer.wait_closed()` in try/except), sets reader/writer to None.
   - `async start(self)` — calls `connect()`, then creates `_reconnect_task = asyncio.create_task(self._reconnect_loop())`.
   - `async stop(self)` — cancels `_reconnect_task` if exists (cancel + await with CancelledError catch), then calls `disconnect()`.
   - `async _reconnect_loop(self)` — infinite loop: sleep(delay), if not connected attempt connect(), reset delay to 2.0 on success, double delay (capped at 60.0) on failure. Initial delay = 2.0.
   - `async read_weight(self) -> dict` — raises `ConnectionError("Scale not connected")` if not connected. Acquires `_lock`, writes `b"SI\r\n"`, drains, reads line with `asyncio.wait_for(reader.readline(), timeout=3.0)`. On `ConnectionResetError, asyncio.IncompleteReadError, OSError`: sets `_connected = False`, logs warning, raises `ConnectionError`. Decodes with `ascii` encoding (`errors="replace"`). Returns `_parse_sics_response(line.strip())`.

3. **Module constant:** `SCALE_PORT_DEFAULT = 8001`

Use `from typing import Optional` for type hints. Use `import asyncio, logging, os` from stdlib only — no new packages.
  </action>
  <verify>
Run from backend directory:
```bash
cd backend && python -c "from scale_bridge import ScaleBridge, _parse_sics_response, SCALE_PORT_DEFAULT; print('Import OK')"
```

Test parser directly:
```bash
cd backend && python -c "
from scale_bridge import _parse_sics_response
r = _parse_sics_response('SI S      8505.75 g')
assert r == {'stable': True, 'value': 8505.75, 'unit': 'g', 'raw': 'SI S      8505.75 g'}
r2 = _parse_sics_response('SI D      123.45 mg')
assert r2 == {'stable': False, 'value': 123.45, 'unit': 'mg', 'raw': 'SI D      123.45 mg'}
try:
    _parse_sics_response('ES')
    assert False, 'Should have raised'
except ValueError:
    pass
try:
    _parse_sics_response('SI I')
    assert False, 'Should have raised'
except ValueError:
    pass
print('All parser tests passed')
"
```
  </verify>
  <done>
`backend/scale_bridge.py` exists with ScaleBridge class and _parse_sics_response function. Imports cleanly. Parser correctly handles stable, dynamic, error, and malformed responses.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate ScaleBridge into FastAPI lifespan, add status endpoint and settings</name>
  <files>backend/main.py, backend/.env.example</files>
  <action>
Modify `backend/main.py`:

1. **Add `import os` to imports** (if not already present — check first).

2. **Extend `DEFAULT_SETTINGS` dict** — add two new entries after existing ones:
   ```python
   "scale_host": "",      # Empty = scale disabled; set to IP address to enable
   "scale_port": "8001",  # Default MT-SICS TCP port for Excellence/XSR series
   ```

3. **Extend the `lifespan()` function** — after the existing `seed_admin_user(db)` block and before `yield`, add:
   ```python
   # --- Scale Bridge (Phase 2) ---
   from scale_bridge import ScaleBridge, SCALE_PORT_DEFAULT
   import logging
   logger = logging.getLogger(__name__)

   scale_host = os.environ.get("SCALE_HOST")
   scale_port = int(os.environ.get("SCALE_PORT", str(SCALE_PORT_DEFAULT)))
   if scale_host:
       app.state.scale_bridge = ScaleBridge(host=scale_host, port=scale_port)
       await app.state.scale_bridge.start()
       logger.info(f"ScaleBridge started: {scale_host}:{scale_port}")
   else:
       app.state.scale_bridge = None
       logger.info("SCALE_HOST not set — scale bridge disabled (manual-entry mode)")
   ```
   After `yield`, add shutdown:
   ```python
   # --- Scale Bridge shutdown ---
   if getattr(app.state, 'scale_bridge', None) is not None:
       await app.state.scale_bridge.stop()
   ```

4. **Add `/scale/status` GET endpoint** — at the end of the file with the other endpoints. Uses JWT auth via `Depends(get_current_user)`:
   ```python
   @app.get("/scale/status")
   async def get_scale_status(
       request: Request,
       _current_user=Depends(get_current_user),
   ):
       """Get scale connection status."""
       bridge = getattr(request.app.state, 'scale_bridge', None)
       if bridge is None:
           return {"status": "disabled", "host": None, "port": None}
       return {
           "status": "connected" if bridge.connected else "disconnected",
           "host": bridge.host,
           "port": bridge.port,
       }
   ```
   Note: `Request` is already imported from `fastapi` — verify it's in the existing import line: `from fastapi import FastAPI, Depends, HTTPException, Header, status`. If `Request` is not there, add it.

5. **Update `backend/.env.example`** — add a new section at the end:
   ```
   # --- Scale (Mettler Toledo XSR105DU) ---
   # Set SCALE_HOST to enable automatic weight capture from the balance.
   # Leave commented out for manual-entry mode (no scale required).
   # SCALE_HOST=192.168.1.100
   # SCALE_PORT=8001
   ```
  </action>
  <verify>
Verify main.py imports cleanly:
```bash
cd backend && python -c "import main; print('main.py imports OK')"
```

Verify DEFAULT_SETTINGS has scale entries:
```bash
cd backend && python -c "from main import DEFAULT_SETTINGS; assert 'scale_host' in DEFAULT_SETTINGS; assert 'scale_port' in DEFAULT_SETTINGS; print('Settings OK:', DEFAULT_SETTINGS['scale_host'], DEFAULT_SETTINGS['scale_port'])"
```

Verify .env.example contains SCALE_HOST:
```bash
grep -q "SCALE_HOST" backend/.env.example && echo ".env.example updated" || echo "MISSING"
```

Verify the app starts without SCALE_HOST set (graceful degradation):
```bash
cd backend && unset SCALE_HOST && python -c "
import asyncio
from main import app, lifespan
async def test():
    async with lifespan(app):
        bridge = getattr(app.state, 'scale_bridge', None)
        assert bridge is None, 'Bridge should be None when SCALE_HOST not set'
        print('Graceful degradation: PASS')
asyncio.run(test())
"
```
  </verify>
  <done>
`backend/main.py` extended with: scale_host/scale_port in DEFAULT_SETTINGS, ScaleBridge conditional initialization in lifespan, clean shutdown after yield, and `/scale/status` GET endpoint with JWT auth returning disabled/connected/disconnected status. `.env.example` documents SCALE_HOST and SCALE_PORT. App starts normally without SCALE_HOST set.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create standalone test script</name>
  <files>backend/test_scale.py</files>
  <action>
Create `backend/test_scale.py` — a standalone script that connects to the physical balance and reads a weight. No FastAPI dependency. Uses ScaleBridge class from scale_bridge.py.

```python
#!/usr/bin/env python3
"""
Standalone test script for Mettler Toledo MT-SICS TCP connection.
Tests direct balance communication without FastAPI.

Usage:
    python test_scale.py                    # Uses defaults: 192.168.1.100:8001
    python test_scale.py 10.0.0.50         # Custom host, default port
    python test_scale.py 10.0.0.50 8001    # Custom host and port
"""
import asyncio
import sys

from scale_bridge import ScaleBridge


async def main():
    host = sys.argv[1] if len(sys.argv) > 1 else "192.168.1.100"
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 8001

    print(f"Connecting to {host}:{port}...")
    bridge = ScaleBridge(host=host, port=port)

    ok = await bridge.connect()
    if not ok:
        print(f"FAILED: Could not connect to {host}:{port}")
        print("Check that:")
        print("  1. The balance is powered on")
        print("  2. The Ethernet module is installed and configured")
        print("  3. The IP address and port are correct")
        sys.exit(1)

    print("Connected. Sending SI command...")
    try:
        result = await bridge.read_weight()
        stability = "STABLE" if result["stable"] else "DYNAMIC"
        print(f"Stability: {stability}")
        print(f"Weight:    {result['value']} {result['unit']}")
        print(f"Raw:       {result['raw']!r}")
    except Exception as e:
        print(f"ERROR reading weight: {e}")
        sys.exit(1)
    finally:
        await bridge.disconnect()

    print("\nScale communication test PASSED")


if __name__ == "__main__":
    asyncio.run(main())
```

Make the script executable (add shebang line as shown above).
  </action>
  <verify>
Verify script imports correctly (without actually connecting to hardware):
```bash
cd backend && python -c "
import importlib.util
spec = importlib.util.spec_from_file_location('test_scale', 'test_scale.py')
mod = importlib.util.module_from_spec(spec)
# Don't execute — just verify it parses and imports resolve
print('test_scale.py syntax OK')
"
```

Verify the script accepts --help style usage:
```bash
cd backend && python test_scale.py --help 2>&1 || true
# Script won't have argparse, but verify it doesn't crash on import
```

Verify script file exists and has the shebang:
```bash
head -1 backend/test_scale.py | grep -q "python3" && echo "Shebang OK" || echo "Missing shebang"
```
  </verify>
  <done>
`backend/test_scale.py` exists as a standalone script that imports ScaleBridge, accepts host and port as CLI arguments, connects, sends SI command, and prints parsed weight with stability flag. No FastAPI dependency. Script parses without errors.
  </done>
</task>

</tasks>

<verification>
After all 3 tasks complete, verify the full Phase 2 success criteria:

1. **Standalone test script exists and imports correctly:**
   ```bash
   cd backend && python -c "from test_scale import main; print('test_scale OK')"
   ```

2. **GET /scale/status returns 'disabled' when SCALE_HOST is absent:**
   ```bash
   cd backend && unset SCALE_HOST && python -c "
   import asyncio
   from main import app, lifespan
   async def test():
       async with lifespan(app):
           bridge = getattr(app.state, 'scale_bridge', None)
           assert bridge is None
           print('SC-3 PASS: App starts without SCALE_HOST, bridge is None')
   asyncio.run(test())
   "
   ```

3. **scale_host and scale_port in DEFAULT_SETTINGS:**
   ```bash
   cd backend && python -c "
   from main import DEFAULT_SETTINGS
   assert DEFAULT_SETTINGS.get('scale_host') == ''
   assert DEFAULT_SETTINGS.get('scale_port') == '8001'
   print('SC-4 PASS: Settings seeded')
   "
   ```

4. **ScaleBridge parser handles all response types correctly:**
   ```bash
   cd backend && python -c "
   from scale_bridge import _parse_sics_response
   # Stable
   assert _parse_sics_response('SI S      8505.75 g')['stable'] == True
   # Dynamic
   assert _parse_sics_response('SI D      123.45 mg')['stable'] == False
   # Error responses raise ValueError
   for err in ['ES', 'ET', 'EL', 'SI I', 'SI +', 'SI -', 'SI E', 'SI L']:
       try:
           _parse_sics_response(err)
           assert False, f'Should raise for {err!r}'
       except ValueError:
           pass
   print('Parser: ALL PASS')
   "
   ```

Note: Success criteria 1 and 2 from ROADMAP (physical balance test, GET /scale/status returns 'connected') require hardware access. These are verified by `test_scale.py` and the `/scale/status` endpoint respectively, but cannot be exercised without the physical XSR105DU balance on the network. The code is correct; hardware validation is deferred per STATE.md blocker.
</verification>

<success_criteria>
- `backend/scale_bridge.py` exists with ScaleBridge class and _parse_sics_response function
- `backend/main.py` lifespan conditionally creates ScaleBridge from SCALE_HOST env var
- `backend/main.py` has GET /scale/status endpoint returning disabled/connected/disconnected
- `backend/main.py` DEFAULT_SETTINGS includes scale_host and scale_port
- `backend/test_scale.py` exists as standalone script with no FastAPI dependency
- `backend/.env.example` documents SCALE_HOST and SCALE_PORT
- App starts without error when SCALE_HOST is not set (graceful degradation)
- All existing imports and endpoints in main.py continue to work
</success_criteria>

<output>
After completion, create `.planning/phases/02-scale-bridge/02-01-SUMMARY.md`
</output>
